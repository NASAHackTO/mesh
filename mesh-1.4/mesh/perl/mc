#!/usr/bin/perl
#
# Copyright (C) 2006-2009 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration
# (NASA).  All Rights Reserved.
#
# This software is distributed under the NASA Open Source Agreement
# (NOSA), version 1.3.  The NOSA has been approved by the Open Source
# Initiative.  See http://www.opensource.org/licenses/nasa1.3.php
# for the complete NOSA document.
#
# THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
# KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
# LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
# SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
# A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
# THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
# DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS
# AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY
# GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING
# DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING
# FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS
# ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF
# PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS".
#
# RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS IN ANY
# LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH USE,
# INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND
# HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED
# BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE
# IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
#

# This program is the Mesh Client and provides a simplified user
# interface for invoking remote Mesh commands.

require 5.006_001;
use strict;
use Cwd qw(abs_path);
use Data::Dumper;
use Fcntl qw(:flock :mode);
use File::Basename;
use File::Copy;
use File::Find;
use File::Glob qw(:glob);
use File::Path;
use File::Spec;
use File::Spec::Unix;
use File::Temp qw(tempdir tempfile);
use Getopt::Long qw(:config bundling no_ignore_case require_order);
use IO::Socket::UNIX;
use IPC::Open3;
use List::Util qw(min max);
use POSIX;
use Socket;
use Sys::Hostname;
use Text::ParseWords;

use constant SFTP_APPEND => 0x04;
use constant SFTP_CREAT => 0x08;
use constant SFTP_READ => 0x01;
use constant SFTP_TRUNC => 0x10;
use constant SFTP_WRITE => 0x02;
use constant SFTP_EXCL => 0x20;

our $VERSION = 0.75;

$Data::Dumper::Indent = 0;
$Data::Dumper::Purity = 1;

#########################
#### default options ####
#########################
my %opts = (
    a => "MAPHOST",
    af => "MAPPRINT",
    d => 7,
    i => glob("~/.ssh/id_rsa"),
    p => "MPHOST",
    pf => "MPPRINT",
);

# openssh-specific optimizations
if (qx(ssh -V 2>&1) =~ /openssh/i) {
    # choose more efficient ciphers if available
    if (qx(ssh -c arcfour128,aes128-cbc,blowfish-cbc 2>&1) !~
            /unknown cipher|bad ssh2/i) {
        $opts{ssh_o} .= " -c arcfour128,aes128-cbc,blowfish-cbc";
    }
    # choose more efficient macs if available
    if (qx(ssh -m umac-64\@openssh.com,hmac-md5,hmac-sha1 2>&1) !~
            /unknown mac|bad ssh2/i) {
        $opts{ssh_o} .= ' -m umac-64@openssh.com,hmac-md5,hmac-sha1';
    }
}

my $base = basename($0);

#######################
#### parse options ####
#######################
exit 1 if (!GetOptions(\%opts,
    "a=s", "b", "d=i", "f", "g", "h", "i=s", "k", "keygen-user=s",
    "m=s", "p=s", "r=s", "s=s", "t=s", "u=s", "v",
    "o=s" => sub {
        my ($key, $val) = split(/=|\s+/, $_[1], 2);
        $val = shift @ARGV if (!defined $val);
        $opts{$_[0] . lc($key)} = " $val";
    }
));
# kill agent on exit when in batch mode or new agent forced
$opts{k} = 1 if ($opts{b} || $opts{n});
if ($opts{'keygen-user'}) {
    # format for inclusion on mesh-keygen command line
    $opts{'keygen-user'} = "--user=" . $opts{'keygen-user'};
    # adjust expiration time for keygen users
    $opts{d} = 60;
}
$opts{ssh_l} = "-l $opts{u}" if ($opts{u});
# skip login messages when not in verbose mode
$opts{ssh_q} = '-q' if (!$opts{v});
$opts{tmp_d} = File::Spec->tmpdir;
# set remote transport to client transport
$opts{remote} = $opts{t} if ($opts{t});
my $mc = dirname(abs_path($0)) . "/$base";

################################
#### define aliases for vfs ####
################################
if ($opts{r} || $opts{s}) {
    foreach (qw(a d i m p t u)) {
        $mc .= " -$_ '$opts{$_}'" if ($opts{$_});
    }
    my @ng_cmds = qw(cat cd chgrp chmod chown cmp cp df diff du file ln ls mkdir
        mv pwd rm rmdir test touch);
    my @cmds = qw(grep head less more tail tee wc);
    #TODO: find, more/less without whole file
    #TODO: can't use noglob alias with piped input (set -f destroys input)
    #TODO: support csh
    if ($opts{r} eq 'bash') {
        #TODO: could do redirection by getting orig cmd, rewriting < to
        # cat, rewriting > to tee, then rexec'ing (only if history 1 works)
        print qq|unset -f mc_cd ; |;
        print qq|unset -f mc_ng ; |;
        print qq|unalias $_ ; | foreach (@cmds, @ng_cmds);
        print q|export COMP_WORDBREAKS=${COMP_WORDBREAKS}: ; |;
        print qq|complete -r $_ ; | foreach (@cmds, @ng_cmds);
    } elsif ($opts{s} eq 'bash') {
        # need perl 5.8.5 as glob is broken in earlier versions
        require 5.008_005;
        print qq|mc_cd () { eval `$mc cd "\$@"`; RC=\$?; set +f; return \$RC ; } ; |;
        print qq|mc_ng () { $mc "\$@"; RC=\$?; set +f; return \$RC ; } ; |;
        # aliases where glob can be safely disabled with set -f
        print qq|alias $_='set -f; mc_ng $_$opts{"o$_"}' ; | foreach (@ng_cmds);
        # aliases where glob cannot be disabled as set -f destroys stdin
        print qq|alias $_='$mc $_$opts{"o$_"}' ; | foreach (@cmds);
        print qq|alias cd='set -f; mc_cd' ; |;
        # need to remove : to allow completion of scp-style paths to work
        print q|export COMP_WORDBREAKS=${COMP_WORDBREAKS/\:/} ; |;
        print qq|complete -o default -o filenames -o nospace -C '$mc complete' $_ ; |
            foreach (@cmds, @ng_cmds);
    }
    exit;
}

###################
#### show help ####
###################
$opts{h} = 1 if (scalar(@ARGV) == 0 && !$opts{g});
if ($opts{h}) {
    print "Usage: $base [OPTION]... COMMAND\n";
    print "\n";
    print "Execute COMMAND as if proxied hosts were directly connected.\n";
    print "\n";
    print "Options (defaults in brackets):\n";
    print "    -a MAP       set Mesh Authentication Point to MAP [$opts{a}]\n";
    print "    -b           batch mode (disable key renewal, implies -k)\n";
    print "    -d DAYS      keys are valid for DAYS days [$opts{d}]\n";
    print "    -g           force generation of new key\n";
    print "    -h           help\n";
    print "    -i IDENTITY  set long term identity file to IDENTITY [$opts{i}]\n";
    print "    -k           kill spawned agent (no effect if agent preexists)\n";
    print "    -n           force spawning of new agent\n";
    print "    -oCMD OPTS   set alias options for CMD to OPTS\n";
    print "    -p MP        set Mesh Proxy to MP [$opts{p}]\n";
    print "    -r SHELL     remove aliases for SHELL shell\n";
    print "    -s SHELL     set aliases for SHELL shell\n";
    print "    -t TRANSPORT set transport mechanism to TRANSPORT [sftp]\n";
    print "    -u USER      set remote user to USER [" . getpwuid($<) . "]\n";
    print "    -v           verbose mode\n";
    exit;
}
print STDERR "Using version $VERSION\n" if ($opts{v});

###############################
#### execute local command ####
###############################
if (scalar(@ARGV) > 0) {
    # ignore command if key generation forced and no arguments given
    my $cmd = shift @ARGV;
    if ($cmd !~ /(?:^|\W)(?:bbcp|bbftp|bbscp|globus-url-copy|mesh-keykill|mesh-keytime|pcp\+|rm|rsync|scp|sftp|ssh|ssh-balance)$/ && $< != 0) {
        # resolve all symlinks to support links to host:/path in VFS
        #   (exclude rm so linked targets are not removed)
        #   (exclude root to prevent unintended exposure/modification)
        @ARGV = map {File::Spec::Link->resolve_all($_)} @ARGV;
    }
    my $argv_hostpath = 0;
    $argv_hostpath ||= hostpath($_) foreach (@ARGV);
    if ($cmd =~ /(?:^|\W)pwd$/) {
        print "$ENV{PWD}\n";
        exit;
    } elsif ($cmd !~ /(?:^|\W)(?:bbcp|bbftp|bbscp|globus-url-copy|mesh-keykill|mesh-keytime|pcp\+|rsync|scp|sftp|ssh|ssh-balance)$/ &&
            !$argv_hostpath && (!hostpath($ENV{PWD}) ||
            grep(!/^[-\/]/, @ARGV) == 0 || $cmd =~ /(?:^|\W)complete$/ &&
            $ARGV[1] =~ /^\//)) {
        if ($cmd =~ /(?:^|\W)(?:ls|du)$/ && hostpath($ENV{PWD}) &&
                grep(/^\//, @ARGV) == 0) {
            # add implicit current directory to remote ls/du
            push(@ARGV, $ENV{PWD});
        } else {
            exit if ($cmd =~ /(?:^|\W)complete$/);
            unshift(@ARGV, $cmd);
            unshift(@ARGV, qw(echo builtin)) if ($cmd =~ /(?:^|\W)cd$/);
            @ARGV = map {glob($_)} @ARGV;
            exit WEXITSTATUS(system(@ARGV));
        }
    } elsif ($cmd =~ /(?:^|\W)complete$/) {
        @ARGV = ($ARGV[1]);
    }
    # add previously shifted command back into argument list
    unshift(@ARGV, $cmd);
}

###################################
#### find agent base directory ####
###################################
my $agent_sock = qx(ssh-agent -c);
my $agent_base;
if ($agent_sock =~ /SSH_AUTH_SOCK\s+([^;]+);/) {
    $agent_base = dirname(dirname($1));
} else {
    $agent_base = "/tmp";
}
if ($agent_sock =~ /SSH_AGENT_PID\s+(\d+);/) {
    kill(SIGTERM, $1) && waitpid($1, 0);
}
print STDERR "Agent base directory is $agent_base\n" if ($opts{v});
$agent_sock = undef;

####################
#### find agent ####
####################
if (!$opts{n}) {
    my @agents = glob("$agent_base/ssh-*/agent.*");
    push(@agents, glob("/tmp/ssh-*/agent.*")) if ($agent_base ne "/tmp");
    unshift(@agents, $ENV{SSH_AUTH_SOCK});
    foreach my $agent (@agents) {
        my @stat = stat $agent;
        next if ($stat[4] != $< || ! -S $agent);
        print STDERR "Checking validity of agent socket $agent\n" if ($opts{v});
        $ENV{SSH_AUTH_SOCK} = $agent;
        my $out = qx(ssh-add -l 2>&1);
        next if ($out =~ /open a connection|authentication socket/);
        $agent_sock = $agent;
        last;
    }
}

#####################
#### start agent ####
#####################
if (!defined $agent_sock) {
    print STDERR "Starting agent\n" if ($opts{v});
    $agent_sock = qx(ssh-agent -c);
    if ($opts{k} && $agent_sock =~ /SSH_AGENT_PID\s+(\d+);/) {
        $opts{k} = $1;
        print STDERR "Agent pid is $opts{k}\n" if ($opts{v});
    }
    if ($agent_sock =~ /SSH_AUTH_SOCK\s+([^;]+);/) {
        $agent_sock = $1;
    } else {
        die "Unable to start agent\n";
    }
}
print STDERR "Agent socket is $agent_sock\n" if ($opts{v});
$ENV{SSH_AUTH_SOCK} = $agent_sock;

##################
#### find key ####
##################
my $agent_key;
if (!$opts{g}) {
    # ignore agent keys if key generation forced
    my $agent_keys = qx(ssh-add -l);
    while ($agent_keys =~ /.ssh\/meshkey\.(\d+)/g) {
        if ($1 > time - 60) {
            $agent_key = $1;
            last;
        }
    }
}

#################
#### add key ####
#################
if (!$agent_key && !$opts{g}) {
    # ignore existing keys if key generation forced
    my @keys = glob("~/.ssh/meshkey.[0-9]*");
    foreach my $key (@keys) {
        if ($key =~ /\.(\d+)$/) {
            my $time = $1 - time;
            if ($time < 0) {
                print STDERR "Removing expired key $key\n" if ($opts{v});
                unlink $key;
                unlink "$key.pub";
                next;
            }
            print STDERR "Checking validity of key $key\n" if ($opts{v});
            my $out = qx(ssh-keygen -l -f $key.pub);
            if ($out =~ /not a public key file/) {
                print STDERR "Removing invalid key $key\n" if ($opts{v});
                unlink $key;
                unlink "$key.pub";
                next;
            }
            $agent_key = $key;
            print STDERR "Adding key $agent_key to agent\n" if ($opts{v});
            qx(ssh-add -t $time $agent_key 2>&1);
            die "Unable to add key to agent\n" if ($?);
            last;
        }
    }
}

######################
#### generate key ####
######################
if (!$agent_key || $opts{g}) {
    die "Key generation required but batch mode enabled\n" if ($opts{b});
    print STDERR "Testing initialization of host keys\n" if ($opts{v});
    for my $h (qw(a p)) {
        my $hf = $h . "f";
        my $out = qx(ssh -ax -oBatchMode=yes $opts{ssh_l} $opts{$h} bad-cmd 2>&1);
        if ($out =~ /verification\s+failed/) {
            print STDERR "No host key found for $opts{$h}\n";
            print STDERR "...continue if fingerprint is $opts{$hf}\n";
            qx(ssh -aqx -oStrictHostKeyChecking=ask -oPreferredAuthentications=none $opts{ssh_l} $opts{$h} bad-cmd 2>&1);
        }
    }

    print STDERR "Testing initialization of agent identities\n" if ($opts{v});
    my $out = qx(ssh -ax -i /dev/null -oBatchMode=yes $opts{ssh_l} $opts{a} bad-cmd 2>&1);
    if ($out =~ /verification\s+failed/) {
        die "Host key verification failed for $opts{a}\n"
    } elsif ($out =~ /denied/ && $out =~ /publickey/) {
        if (! -r $opts{i}) {
            print STDERR "Cannot find identity $opts{i}\n";
            print STDERR "...do you wish to generate it? (y/n)  ";
            my $line = <STDIN>;
            $line =~ s/\s*\r?\n$//;
            if ($line eq 'y') {
                print STDERR "Generating identity $opts{i}\n" if ($opts{v});
                system("ssh-keygen -t rsa -f $opts{i}");
                die "Unable to generate identity $opts{i}\n" if ($?);
                chmod(0600, $opts{i});
            } else {
                die "Unable to continue without identity $opts{i}\n";
            }
        }
        print STDERR "Adding identity $opts{i} to agent\n";
        system("ssh-add $opts{i}");
        die "Unable to add identity to agent\n" if ($?);
        print STDERR "Testing initialization of identity $opts{i}\n" if ($opts{v});
        $out = qx(ssh -ax -i /dev/null -oBatchMode=yes $opts{ssh_l} $opts{a} bad-cmd 2>&1);
        if ($out =~ /denied/ && $out =~ /publickey/) {
            print STDERR "Checking validity of public key $opts{i}.pub\n" if ($opts{v});
            $out = qx(ssh-keygen -l -f $opts{i}.pub) if (-r "$opts{i}.pub");
            if ($out =~ /not a public key file/ || ! -r "$opts{i}.pub") {
                print STDERR "Generating public key $opts{i}.pub from identity $opts{i}\n";
                system("ssh-keygen -y -f $opts{i} >$opts{i}.pub");
                if ($?) {
                    unlink "$opts{i}.pub";
                    die "Unable to generate public key $opts{i}.pub\n" 
                }
            }
            print STDERR "Initializing identity on $opts{a} (provide login information)\n";
            system("ssh $opts{ssh_q} -x -oPubkeyAuthentication=no $opts{ssh_l} $opts{a} mesh-keygen --init-add <$opts{i}.pub");
            die "Unable to initialize identity\n" if ($?);
        }
    } elsif ($out =~ /denied/ && $out =~ /command/) {
        # identity already loaded
    } else {
        die "Unknown output encountered: '$out'\n"
    }
    if (! -d glob("~/.ssh")) {
        print STDERR "Creating ~/.ssh\n" if ($opts{v});
        mkdir glob("~/.ssh");
        chmod(0700, glob("~/.ssh"));
    }
    my $time = time + $opts{d} * 24 * 60 * 60;
    $agent_key = glob("~/.ssh/meshkey.$time");
    $time -= time;
    print STDERR "Generating key on $opts{p} (provide login information)\n";
    system("ssh $opts{ssh_q} -Ax -oPubkeyAuthentication=no $opts{ssh_l} $opts{p} mesh-keygen " . $opts{'keygen-user'} . " >$agent_key");
    if ($? || -z $agent_key) {
        unlink $agent_key;
        die "Unable to generate key\n";
    }
    chmod(0600, $agent_key);
    print STDERR "Generating public key $agent_key.pub from private key $agent_key\n" if ($opts{v});
    system("ssh-keygen -y -f $agent_key >$agent_key.pub");
    print STDERR "Adding key $agent_key to agent\n" if ($opts{v});
    system("ssh-add -t $time $agent_key");
    die "Unable to add key to agent\n" if ($?);

    #######################
    #### update client ####
    #######################
    if (!$opts{"keygen-user"}) {
        # do not update client when key generated for different user
        my $mcv = qx(ssh -Aqx -oBatchMode=yes $opts{ssh_l} $opts{p} mesh-update --file=mc --version);
        $mcv =~ s/\s*\r?\n$//;
        print STDERR "Latest client version is $mcv\n" if ($opts{v});
        if ($mcv > $VERSION) {
            print STDERR "A newer version of the client is available ($mcv vs. $VERSION)\n";
            print STDERR "...do you wish to replace the current version? (y/n)  ";
            my $line = <STDIN>;
            $line =~ s/\s*\r?\n$//;
            if ($line eq 'y') {
                system("ssh -Aqx -oBatchMode=yes $opts{ssh_l} $opts{p} mesh-update --file=mc >$mc");
            }
        }
    }

    # ignore command if key generation forced and no arguments given
    exit if ($opts{g} && scalar(@ARGV) == 0);
}

##########################
#### clean up on exit ####
##########################
END {exit_clean()};
use sigtrap qw(handler exit_clean normal-signals);

########################
#### modify command ####
########################
# make sure to keep the space at the end
$opts{sshmp} = "ssh $opts{ssh_q} -Ax $opts{ssh_o} -oBatchMode=yes $opts{ssh_l} $opts{p} ";
# re-add options for when there is no proxy
$opts{ssh} = "$opts{sshmp}ssh $opts{ssh_q} -ax $opts{ssh_o} -oBatchMode=yes $opts{ssh_l}";
print STDERR "Old command is '" . join("' '", @ARGV) . "'\n" if ($opts{v});
my $argc = scalar(@ARGV);
if ($ARGV[0] =~ /(?:^|\W)(?:scp|sftp)$/) {
    my ($fh, $wrap) = tempfile(UNLINK => 1);
    print $fh "#!/bin/sh\nexec $opts{ssh} \$@";
    close $fh;
    chmod(0700, $wrap);
    splice(@ARGV, 1, 0, ("-S", $wrap));
} elsif ($ARGV[0] =~ /(?:^|\W)bbcp$/) {
    splice(@ARGV, 1, 0, ("-T", "$opts{ssh} %H bbcp"));
} elsif ($ARGV[0] =~ /(?:^|\W)(?:bbftp|bbscp)$/) {
    splice(@ARGV, 1, 0, ("-L", $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)globus-url-copy$/) {
    my $dir = glob("~/.globus");
    mkdir $dir if (! -d $dir);
    my $file = "$dir/gridftp-ssh";
    open(FILE, '>', $file);
    print FILE "#!/bin/sh\n$opts{ssh} \$2 sshftp";
    close FILE;
    chmod(0700, $file);
    # reduce $argc since no additional args are spliced onto @ARGV
    $argc--;
} elsif ($ARGV[0] =~ /(?:^|\W)pcp\+$/) {
    splice(@ARGV, 1, 0, ("-s", "$opts{ssh_l} $opts{p}"));
} elsif ($ARGV[0] =~ /(?:^|\W)rsync$/) {
    splice(@ARGV, 1, 0, ("-e", $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)ssh$/) {
    splice(@ARGV, 0, 1, split(/\s+/, $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)(?:mesh-keykill|mesh-keytime|ssh-balance)$/) {
    splice(@ARGV, 0, 0, split(/\s+/, $opts{sshmp}));
}
print STDERR "New command is '" . join("' '", @ARGV) . "'\n" if ($opts{v});

################################
#### execute remote command ####
################################
if (scalar(@ARGV) > $argc) {
    # use system instead of exec so can clean up afterwards
    my $rc = WEXITSTATUS(system(@ARGV));
    exit $rc;
}

###################
#### find sftp ####
###################
my @sftps = glob("$opts{tmp_d}/mesh-*/sftp.*");
my $sftp_time = -1;
my $sftp_sock;
foreach my $sftp (@sftps) {
    my @stat = stat $sftp;
    next if ($stat[4] != $< || ! -S $sftp || $stat[9] < $sftp_time);
    print STDERR "Checking validity of sftp socket $sftp\n" if ($opts{v});
    my $sftpd = IO::Socket::UNIX->new(
        Peer => $sftp,
        Proto => 'tcp',
    );
    next if (!$sftpd);
    $sftp_sock = $sftp;
    $sftp_time = $stat[9];
}

############################
#### start sftp for vfs ####
############################
if (!defined $sftp_sock) {
    $opts{sftp_d} = tempdir("mesh-XXXXXXXX", DIR => $opts{tmp_d});
    $sftp_sock = "$opts{sftp_d}/sftp.$$";
    mkdir "$opts{sftp_d}/empty";
    sftp_require($opts{sftp_d}) if (!eval "require Net::SFTP::Foreign");

    my $server = IO::Socket::UNIX->new(
        Listen => 10,
        Local => $sftp_sock,
        Proto => 'tcp',
    );

    if (fork) {
        close $server;
        # prevent cleanup
        $opts{sftp_d} = undef;
        $opts{k} = undef;
    } else {
        close STDIN;
        close STDOUT;
        close STDERR;
        setsid;
        open(STDIN, "</dev/null");
        open(STDOUT, ">/dev/null");
        open(STDERR, ">/dev/null");

        while (my $client = $server->accept) {
            $_ = <$client>;
            if (!$_) {
                close $client;
                next;
            }
            my $pwd;
            eval;
            my %copts;
            for (my $i = 1; $i < scalar(@ARGV); $i++) {
                if ($ARGV[$i] =~ /^--(\w+)$/) {
                    $copts{$1} = 1;
                } elsif ($ARGV[$i] =~ /^--(\w+)=(.*)$/) {
                    $copts{$1} = $2;
                } elsif ($ARGV[$i] =~ /^-(\d+)$/) {
                    $copts{$1} = 1;
                } elsif ($ARGV[$i] =~ /^-(\w+)$/) {
                    $copts{$_} = 1 foreach (split(//, $1));
                } elsif (!defined $copts{-arg1} && $ARGV[0] =~
                        /(?:^|\W)(?:chgrp|chown|chmod|grep)$/) {
                    # first non-option argument
                    $copts{-arg1} = $ARGV[$i];
                } else {
                    my ($host, $path) = hostpath($ARGV[$i]);
                    if ($host eq 'localhost')  {
                        # rewrite arg for /localhost/path case
                        $ARGV[$i] = $path;
                        if ($path !~ /^\//) {
                            # relative path
                            ($host, $path) = hostpath($pwd);
                            $path .= "/" . $ARGV[$i] if ($host ne 'localhost');
                        }
                    }
                    if ($host ne 'localhost') {
                        $path = File::Spec::Unix->canonpath($path);
                        1 while ($path =~ s/(?:^|\/?(?:[^\/]*\/))\.\.//);
                        $path = "/" if (!$path);
                        # original argument
                        $copts{-arg} = splice(@ARGV, $i--, 1);
                        if ($path =~ /[*?[]/ &&
                                $ARGV[0] !~ /(?:^|\W)(?:ls|complete)$/) {
                            my @glob = sftp($host)->glob($path, names_only => 1);
                            next if (scalar(@glob) == 0);
                            $path = shift @glob;
                            @glob = map {hostpath($host, $_)} @glob;
                            splice(@ARGV, $i + 1, 0, @glob);
                        }
                        push(@{$copts{-argv}}, hostpath($host, $path));
                        if ($ARGV[0] =~ /(?:^|\W)(cd|chgrp|chmod|chown|complete|df|du|head|ls|mkdir|rm|rmdir|tail|test|touch)$/) {
#TODO: this should probably be done differently (i.e. should rename
#      all paths, then execute subs on all args at once)
                            $copts{-argsleft} = scalar(@ARGV) - $i - 1;
                            my $sub = \&{"v$1"};
                            &{$sub}($client, $host, $path, \%copts);
                            last if ($1 eq 'cd');
                        } elsif ($ARGV[0] !~ /(?:^|\W)(?:cp|ln|mv|tee)$/) {
                            #### commands that use tmp files for remote files ####
                            my $tmp = sftp_tmp() . "-" . basename($path);
                            if ($ARGV[0] =~ /(?:^|\W)file$/) {
                                #### commands that use first n bytes of files ####
                                open(FILE, '>', $tmp);
                                my $fh = sftp($host)->open($path);
                                print FILE sftp($host)->read($fh, 4096);
                                close $fh;
                                close FILE;
                            } else {
                                #### commands that use entire files ####
                                if ($tmp ne $copts{-arg}) {
                                    my $ref = {};
                                    transport('get', $host, $path, $tmp, $ref);
                                    transport('end', $host);
                                    #TODO: do something with error
                                }
                            }
                            splice(@ARGV, ++$i, 0, $tmp);
                            $copts{-argc}++;
                        }
                    } else {
                        $copts{-argc}++;
                        push(@{$copts{-argv}}, glob($ARGV[$i]));
                    }
                }
            }

            if ($ARGV[0] =~ /(?:^|\W)(cp|ln|mv|tee)$/) {
                #### commands that process all arguments at once ####
                my $sub = \&{"v$1"};
                &{$sub}($client, \%copts);
            } 
            if ($copts{-argc} || $copts{-arg1} && $ARGV[0] =~ /(?:^|\W)grep$/) {
                #### commands that execute locally on local files ####
                if ($ARGV[0] =~ /(?:^|\W)ls$/) {
                    # add directory to ls output
                    sftp_echo($client, "");
                    sftp_echo($client, $ARGV[-1] . ":")
                        if ($copts{-argc} == 1 && -d $ARGV[-1]);
                }
                @ARGV = map {glob($_)} @ARGV;
                sftp_cmd($client, @ARGV);
            }
            close $client;
        }
        exit;
    }
}

#############################
#### execute vfs command ####
#############################
my $server = IO::Socket::UNIX->new(
    Peer => $sftp_sock,
    Proto => 'tcp',
);
print $server scalar(Data::Dumper->Dump([\@ARGV, $ENV{PWD},
    $ENV{SSH_AUTH_SOCK}], [qw(*ARGV pwd agent_sock)])) . "\n";
my $rc = 0;
if ($ARGV[0] =~ /(?:^|\W)tee$/) {
    while (<STDIN>) {
        print;
        print $server $_;
    }
} else {
    while (<$server>) {
        eval;
        $rc |= WEXITSTATUS(system(@ARGV));
        unlink grep(/meshtmp-/, @ARGV);
    }
}
exit $rc;

################
#### escape ####
################
# return uri-escaped version of given string
sub escape {
    my $text = shift;
    $text =~ s/([^A-Za-z0-9\-_.!~*'()\/])/sprintf("%%%02X", ord($1))/eg
        if (defined $text);
    return $text;
}

####################
#### exit_clean ####
####################
# clean up agents/directories and exit
sub exit_clean {
    my $rc = $?;

    if ($opts{k} > 1) {
        # kill spawned agent
        print STDERR "Killing agent with pid $opts{k}\n" if ($opts{v});
        kill(SIGTERM, $opts{k}) && waitpid($opts{k}, 0);
    }

    if ($opts{sftp_d} =~ /mesh-.{8}$/) {
        # rmtree complains about current directory without chdir
        chdir "/";
        # remove temporary directory and all contents
        rmtree($opts{sftp_d});
    }

    exit $?;
}

##############
#### fqdn ####
##############
# return fully qualified version of given host name
sub fqdn {
    my $host = shift;
    if ($host =~ /^\d+\.\d+\.\d+\.\d+$/) {
        my $name = gethostbyaddr(inet_aton($host), AF_INET);
        return $name if ($name);
    } else {
        my @cols = gethostbyname($host);
        return $cols[0] if ($cols[0]);
    }
    return $host;
}

##################
#### hostpath ####
##################
# return parsed host/path in list context or true if remote path in scalar
sub hostpath {
    my $path = $_[-1];
    my $host = scalar(@_) > 1 ? $_[0] : 'localhost';
    if (scalar(@_) > 1) {
        # multiple arguments
        # return host-path for non-localhost and original path otherwise
        return $path if ($host eq 'localhost');
        return "$host:$path";
    } elsif ($path =~ /^([^\/:]+):(.*)?/) {
        my ($h, $p) = ($1, $2);
        # remove user name if specified
        #TODO: do something with user?
        $h = (split(/@/, $h))[-1];
        if ($h ne 'file' && $p !~ /^\/\//) {
            # single host-path argument in scp format
            ($host, $path) = ($h, $p);
            # remove leading ~/ since it is implied
            $path =~ s/^~\/+//;
            # resolve home dir for relative paths
            if (wantarray && $path !~ /^\//) {
                $path = sftp($host)->cwd . "/" . $path;
            }
        }
    }
    # for list context, return (host, path)
    # for scalar context, return true if non-localhost host-path
    return wantarray ? ($host, $path) : ($host ne 'localhost' ? 1 : 0);
}

##############
#### sftp ####
##############
# return new/cached sftp connection to given host
sub sftp {
    my $host = shift;
    my $no_cwd = shift;
    
    if ($opts{"sftp_$host"}) {
        # use cwd to check for dead connection
        $opts{"sftp_$host"}->cwd if (!$no_cwd);
        # return cached connection to host if still connected
        return $opts{"sftp_$host"} if ($opts{"sftp_$host"}->{_connected});
    }
    # use global agent socket for authentication
    $ENV{SSH_AUTH_SOCK} = $agent_sock;
    # create and cache new connection to host
    $opts{"sftp_$host"} = Net::SFTP::Foreign->new(
        autoflush => 1,
        open2_cmd => "$opts{ssh} -s $host sftp",
    );
    if ($host !~ /\./) {
        my $fqdn = fqdn($host);
        # cache under fully qualified host name as well
        $opts{"sftp_$fqdn"} = $opts{"sftp_$host"} if ($fqdn ne $host);
    }
    return $opts{"sftp_$host"};
}

##################
#### sftp_cmd ####
##################
# execute given command via given socket
sub sftp_cmd {
    my $ref = shift;
    if (ref $ref eq 'IO::Socket::UNIX') {
        print $ref scalar(Data::Dumper->Dump([[@_]], [qw(*ARGV)])) . "\n";
    }
}

###################
#### sftp_echo ####
###################
# print given message via given socket or set text in given hash
sub sftp_echo {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
    } else {
        $ref->{text} .= join(" ", @_);
    }
}

####################
#### sftp_error ####
####################
# print given error message via given socket or set error text in given hash
sub sftp_error {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
        # use false to set non-zero exit code
        print $ref scalar(Data::Dumper->Dump([["false"]], [qw(*ARGV)])) . "\n";
    } else {
        # indicate error using special delimiter
        $ref->{text} .= "\\E" . join(" ", @_);
    }
}

######################
#### sftp_warning ####
######################
# print given warning message via given socket or set warning text in given hash
sub sftp_warning {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
        # use false to set non-zero exit code
        print $ref scalar(Data::Dumper->Dump([["false"]], [qw(*ARGV)])) . "\n";
    } else {
        # indicate warning using special delimiter
        $ref->{text} .= "\\W" . join(" ", @_);
    }
}

#################
#### sftp_ls ####
#################
# return formatted ls string of given remote file
sub sftp_ls {
    #TODO: size is negative in some cases (perhaps showing 64-bit results
    #      on 32-bit system?
    my ($name, $attrs) = ($_[0]->{filename}, $_[0]->{a});
    $name = basename($name) if ($_[1]);
    return $name if (!$_[2]);
    $name = "$name -> $_[0]->{link}" if ($_[0]->{link});
    my $user = getpwuid($attrs->uid);
    $user = $attrs->uid if (!$user);
    my $group = getgrgid($attrs->gid);
    $group = $attrs->gid if (!$group);
    return sprintf("%10s %4d %7s %7s %9d %12s %s",
        sftp_ls_mode($attrs->perm), 1, $user, $group, $attrs->size, 
        strftime("%b %d  %Y", localtime $attrs->mtime), $name);
}

######################
#### sftp_ls_mode ####
######################
# return formatted ls permission string corresponding to given mode
sub sftp_ls_mode {
    my $mode = shift;
    my @perms = qw(--- --x -w- -wx r-- r-x rw- rwx);
    my @ftype = qw(. p c ? d ? b ? - ? l ? s ? ? ?);
    $ftype[0] = '';
    my $setids = ($mode & 07000) >> 9;
    my @permstrs = @perms[
        ($mode & 0700) >> 6, ($mode & 0070) >> 3, $mode & 0007];
    my $ftype = $ftype[($mode & 0170000) >> 12];
  
    if ($setids) {
        $permstrs[2] =~ s/([-x])$/$1 eq 'x' ? 't' : 'T'/e if ($setids & 01);
        $permstrs[0] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e if ($setids & 04);
        $permstrs[1] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e if ($setids & 02);
    }
  
    return join('', $ftype, @permstrs);
}

##################
#### sftp_tmp ####
##################
# return new temporary file name (with handle in array context)
sub sftp_tmp {
    my %dir;
    # create in vfs socket directory if it exists
    $dir{DIR} = defined $opts{sftp_d} ? $opts{sftp_d} : $opts{tmp_d};
    my ($tmpfh, $tmp) = tempfile("meshtmp-XXXXXXXX", %dir);
    if (wantarray) {
        # in array context, return both file handle and file name
        return ($tmpfh, $tmp);
    } else {
        close $tmpfh;
        # in scalar context, return just file name
        return $tmp;
    }
}

###################
#### transport ####
###################
my %tcmds;
sub transport {
    my ($op, $host, $src, $dst, $ref) = @_;
    my $rsize;
    $tcmds{$host} = [] if ($host && !defined $tcmds{$host});
    if ($op eq 'end' && !defined $host) {
        my @hosts = keys %tcmds;
        # localhost must be first to create directories
        $rsize += transport($op, 'localhost') if (grep(/^localhost$/, @hosts));
        foreach $host (keys %tcmds) {
            $rsize += transport($op, $host) if ($host ne 'localhost');
        }
        return $rsize;
    }
    if ($op eq 'end' && ($host eq 'localhost' && $opts{local} eq 'rsync' ||
            $host ne 'localhost' && $opts{remote} eq 'rsync')) {
        # rsync can do both local and remote copies
        my %errs;
        my ($fh, $tmp) = sftp_tmp();
        my $sep = chr(0);
        my ($shost, $spath, $dhost, $dpath, $args);
        if ($host eq 'localhost') {
            $shost = "";
            $dhost = "";
        } else {
            $args = "-e '$opts{ssh}'";
        }
        foreach my $cmd (@{$tcmds{$host}}) {
            ($op, $src, $dst, $ref) = @{$cmd};
            if ($op !~ /^(?:get|put)$/ || $ref->{bytes}) {
                transport_default($host, $cmd);
                next;
            }
            if (!defined $shost) {
                $shost = $op eq 'get' ? "$host:" : "";
                $dhost = $op eq 'put' ? "$host:" : "";
            }
            # find longest common suffix starting with "/"
            if ("$src$sep$dst" =~ /^.*?(\/.*)$sep.*\1$/) {
                my $lcs = $1;
                if ($spath && $src eq "$spath$lcs" && $dst eq "$dpath$lcs") {
                    print $fh "$lcs\n";
                    $errs{"$spath$lcs"} = $ref;
                    $errs{"$dpath$lcs"} = $ref;
                    next;
                } elsif ($spath) {
                    # next file has different prefix so process current batch
                    close $fh;
                    $rsize += transport_rsync($args, $tmp,
                        "$shost$spath $dhost$dpath", \%errs);
                    %errs = ();
                    open($fh, '>', $tmp);
                }
                print $fh "$lcs\n";
                $spath = $src;
                $spath =~ s/$lcs$//;
                $dpath = $dst;
                $dpath =~ s/$lcs$//;
                $errs{"$spath$lcs"} = $ref;
                $errs{"$dpath$lcs"} = $ref;
            } else {
                # no common suffix implies single file copy with rename
                $src =~ s/ /\\\ /g;
                $dst =~ s/ /\\\ /g;
                $rsize += transport_rsync($args, "",
                    "$shost$src $dhost$dst", \%errs);
            }
        }
        close $fh;
        if ($spath) {
            $rsize += transport_rsync($args, $tmp,
                "$shost$spath $dhost$dpath", \%errs);
        }
        unlink $tmp;
    } elsif ($op eq 'end' && $host eq 'localhost') {
        transport_default($host, $_) foreach (@{$tcmds{$host}});
    } elsif ($op eq 'end') {
        if ($opts{remote} eq 'bbftp') {
            my %errs;
            my ($fh, $tmp) = sftp_tmp();
            # must keep write access to handle warnings/corruption
            print $fh "setoption nokeepmode\n";
            print $fh "setrecvwinsize 4096\n";
            print $fh "setsendwinsize 4096\n";
            print $fh "setbuffersize 4096\n";
            foreach my $cmd (@{$tcmds{$host}}) {
                ($op, $src, $dst, $ref) = @{$cmd};
                if ($op eq 'rget') {
                    sftp($host)->find($src,
                        follow_links => 1,
                        wanted => sub {
                            if (S_ISDIR($_[1]->{a}->perm)) {
                                my $rdst = $_[1]->{filename};
                                $rdst =~ s/^$src\/?//;
                                $rdst = "$dst/$rdst";
                                my $s = "mget $_[1]->{filename}/* $rdst";
                                print $fh "$s\n";
                                $errs{$s} = $ref;
                           }
                           return undef;
                        });
                } elsif ($op eq 'rput') {
                    find({follow_fast => 1, follow_skip => 2, no_chdir => 1,
                        wanted => sub {
                            if (-d $_) {
                                my $rdst = $_;
                                $rdst =~ s/^$src\/?//;
                                $rdst = "$dst/$rdst";
                                my $s = "mput $_/* $rdst";
                                print $fh "$s\n";
                                $errs{$s} = $ref;
                            }
                        }}, $src);
                } elsif ($op =~ /^(?:get|put)$/ && !$ref->{bytes} &&
                        "$src$dst" !~ /\s/) {
                    # bbftp cannot handle spaces in file names
                    my $s = "$op $src $dst";
                    print $fh "$s\n";
                    $errs{$s} = $ref;
                } else {
                    transport_default($host, $cmd);
                }
            }
            close $fh;
            if (scalar(keys %errs)) {
                my $out = qx(bbftp -p 8 -r 1 -L "$opts{ssh}" -i $tmp $host 2>&1);
                $out =~ s/Child starting\s*//g;
                if (! -f "$tmp.res" && $out =~ /BBFTP-ERROR-(\d+)/) {
                    my $code = $1;
                    my $type = ($code <= 30 || $code > 70 &&
                        $code <= 90 || $code >= 100) ? "\\E" : "\\W";
                    foreach my $op (keys %errs) {
#TODO: this needs work as error may be related to only one file
#      ?? if so, need an example of this...
                        $errs{$op}->{text} = "$type$out";
                    }
                } else {
                    my @lines = split(/\s*\n\s*/, $out);
                    if (open(FILE, '<', "$tmp.res")) {
                        my $i = 0;
                        while (<FILE>) {
                            next if (/Child starting/);
                            if (/(.*)\s+FAILED$/) {
                                my $op = $1;
                                # ignore option failure
                                next if (!$errs{$op});
                                my $type = "\\E";
                                if ($lines[$i] =~ /BBFTP-ERROR-(\d+)/) {
                                    my $code = $1;
                                    $type = "\\W"
                                        if ($code > 30 && $code <= 70 ||
                                            $code > 90 && $code < 100);
                                }
                                $errs{$op}->{text} = "$type$lines[$i]";
                                $i++;
                            } elsif (/(.*)\s+OK$/) {
                                my $op = $1;
                                # ignore option success
                                next if (!$errs{$op});
                                $errs{$op}->{text} = 0;
                            }
                        }
                        close FILE;
                    }
                }
                unlink "$tmp.res";
                foreach my $op (keys %errs) {
                    if (!defined $errs{$op}->{text}) {
                        sftp_error($errs{$op},
                            "bbftp failure: " . substr($out, 0, 256));
                    }
                }
            }
            unlink $tmp;
            transport_default($host, $_, 1) foreach (@{$tcmds{$host}});
        } elsif ($opts{remote} eq 'globus-url-copy') {
            # make sure gridftp-ssh is set up properly
            my $dir = glob("~/.globus");
            mkdir $dir if (! -d $dir);
            my $file = "$dir/gridftp-ssh";
            open(FILE, '>', $file);
            print FILE "#!/bin/sh\n$opts{ssh} \$2 sshftp";
            close FILE;
            chmod(0700, $file);

            my %errs;
            my ($fh, $tmp) = sftp_tmp();
            foreach my $cmd (@{$tcmds{$host}}) {
                ($op, $src, $dst, $ref) = @{$cmd};
                if ($op =~ /^(r)?(?:get|put)$/) {
                    my $slash = $1 ? "/" : "";
                    if ($op =~ /put/) {
                        $errs{"STOR $dst"} = $ref;
                        $src = "file://" . escape($src) . $slash;
                        $dst = "sshftp://$host" . escape($dst);
                    } else {
#TODO: this doesn't work with connection/allocation errors
                        $errs{"RETR $src"} = $ref;
                        $src = "sshftp://$host" . escape($src) . $slash;
                        $dst = "file://" . escape($dst);
                    }
                    if ($ref->{bytes}) {
                        my @ranges = split(/,/, $ref->{bytes});
                        foreach my $range (@ranges) {
                            my ($x1, $x2) = split(/-/, $range);
                            print $fh "$src $dst $x1,", $x2 - $x1, "\n";
                        }
                    } else {
                        print $fh "$src $dst\n";
                    }
                } else {
                    transport_default($host, $cmd);
                }
            }
            close $fh;

            if (scalar(keys %errs) &&
#TODO: gridftp hangs with one file and -p 8 and sometimes cannot
#      allocate the buffer size specified
                    #open(OUT, "globus-url-copy -dbg -cd -p 8 -bs 4M -tcp-bs 4M -r -f $tmp 2>&1|"))
                    open(OUT, "globus-url-copy -dbg -cd -r -f $tmp 2>&1|")) {
                my $key;
                my $msg;
                while (my $line = <OUT>) {
                    $line =~ s/\s*\r?\n$//;
                    if ($errs{$line}) {
                        $key = $line;
                    } elsif ($key) {
                        $msg .= "$line\n" if ($line && $line !~ /^debug:/);
                        if ($line =~ /operation complete/) {
                            if ($msg !~ /Transfer Complete/) {
                                sftp_error($errs{$key}, $msg);
                            }
                            $key = undef;
                            $msg = undef;
                        }
                    }
                }
                close OUT;
            } else {
                foreach my $err (values %errs) {
                    sftp_error($err, "Unable to run globus-url-copy");
                }
            }

            transport_default($host, $_, 1) foreach (@{$tcmds{$host}});
        } else {
            transport_default($host, $_) foreach (@{$tcmds{$host}});
        }
    } else {
        push(@{$tcmds{$host}}, [$op, $src, $dst, $ref]);
        return;
    }

    delete $tcmds{$host};

    # return is only defined during an end when rsync is used
    return $rsize;
}

###########################
#### transport_default ####
###########################
sub transport_default {
    my ($host, $cmd, $rm) = @_;
    my ($op, $src, $dst, $ref) = @{$cmd};
    if ($host eq 'localhost') {
        if (!$rm && $op =~ /^(?:get|put)$/ && !$ref->{bytes}) {
            # create implicit directories
            mkpath(dirname($dst));
            copy($src, $dst) or sftp_error($ref, "$!");
        } elsif (!$rm && $op eq 'mkdir') {
            # ignore if directory exists
            -d $dst or mkdir $dst or sftp_error($ref, "$!");
        } elsif (($rm || !defined $rm) && $op eq 'rm') {
            unlink $src or sftp_error($ref, "$!");
        } elsif (($rm || !defined $rm) && $op eq 'rrm') {
            sftp_error($ref, rmtree($src));
        } elsif (!$rm && $op eq 'ln') {
            readlink($dst) eq $src or symlink($src, $dst) or
                sftp_error($ref, "$!");
        } elsif (!$rm && $op =~ /^(?:get|put)$/ && $ref->{bytes}) {
            # create implicit directories
            mkpath(dirname($dst));
            my @ranges = split(/,/, $ref->{bytes});
            if (sysopen(SRC, $src, O_RDONLY)) {
                if (sysopen(DST, $dst, O_RDWR | O_CREAT)) {
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        sysseek(SRC, $x1, 0) or
                            sftp_error($ref, "Unable to seek source: $!");
                        sysseek(DST, $x1, 0) or
                            sftp_error($ref, "Unable to seek destination: $!");
                        my $size = 8 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf;
                            my $n = sysread(SRC, $buf, $size);
                            sftp_error($ref, "Unable to read source: $!")
                                if (!defined $n);
                            defined syswrite(DST, $buf, $n) or
                                sftp_error($ref, "Unable to write destination: $!");
                        }
                        #TODO: need to trunc if dst has more bytes than src
                    }
                    close DST;
                } else {
                    sftp_error($ref, "Unable to open destination: $!");
                }
                close SRC;
            } else {
                sftp_error($ref, "Unable to open source: $!");
            }
        } elsif (!$rm && $op eq 'chattr') {
            my @attrs = split(/,/, $ref->{attrs});
            # don't return error for chown since unlikely to succeed
            chown($attrs[1], $attrs[2], $dst);
            chmod($attrs[0], $dst) or
                sftp_error($ref, "$!") and return;
            utime($attrs[3], $attrs[4], $dst) or
                sftp_error($ref, "$!") and return;
        }
    } else {
        # must keep write access to handle warnings/corruption
        my %extra = (copy_perm => 0);
        if (!$rm && $op eq 'get' && !$ref->{bytes}) {
            # create implicit directories
            mkpath(dirname($dst));
            sftp($host)->get($src, $dst, %extra) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'mkdir') {
            vmkdir($ref, $host, $dst, {-overwrite => 1});
        } elsif (!$rm && $op eq 'put') {
            # create implicit directories
            sftp($host)->mkpath(dirname($dst));
            sftp($host)->put($src, $dst, %extra) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'rget') {
            sftp($host)->rget($src, $dst) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (($rm || !defined $rm) && $op eq 'rm') {
            sftp($host)->remove($src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'rput') {
            sftp($host)->rput($src, $dst) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (($rm || !defined $rm) && $op eq 'rrm') {
            sftp($host)->rremove($src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'ln') {
            # src and dst are reversed in sftp symlink
            sftp($host)->readlink($dst) eq $src or
                sftp($host)->symlink($dst, $src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'get' && $ref->{bytes}) {
            my @ranges = split(/,/, $ref->{bytes});
            my $src_fh = sftp($host)->open($src, SFTP_READ);
            if ($src_fh) {
                # create implicit directories
                mkpath(dirname($dst));
                if (sysopen(DST, $dst, O_RDWR | O_CREAT)) {
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        defined sftp($host)->seek($src_fh, $x1, 0) or
                            sftp_error($ref, "Unable to seek source: " .
                                sftp($host, 1)->error);
                        sysseek(DST, $x1, 0) or
                            sftp_error($ref, "Unable to seek destination: $!");
                        my $size = 8 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf = sftp($host)->read($src_fh, $size);
                            sftp_error($ref, "Unable to read source: " .
                                sftp($host, 1)->error) if (!defined $buf);
                            defined syswrite(DST, $buf, length($buf)) or
                                sftp_error($ref, "Unable to write destination: $!");
                        }
                        #TODO: need to trunc if dst has more bytes than src
                    }
                    close DST;
                } else {
                    sftp_error($ref, "Unable to open destination: $!");
                }
                sftp($host)->close($src_fh);
            } else {
                sftp_error($ref, "Unable to open source: " .
                    sftp($host, 1)->error);
            }
        } elsif (!$rm && $op eq 'put' && $ref->{bytes}) {
            my @ranges = split(/,/, $ref->{bytes});
            if (sysopen(SRC, $src, O_RDONLY)) {
                # create implicit directories
                sftp($host)->mkpath(dirname($dst));
                my $dst_fh = sftp($host)->open($dst, SFTP_WRITE | SFTP_CREAT);
                if ($dst_fh) {
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        sysseek(SRC, $x1, 0) or
                            sftp_error($ref, "Unable to seek source: $!");
                        defined sftp($host)->seek($dst_fh, $x1, 0) or
                            sftp_error($ref, "Unable to seek destination: " .
                                sftp($host, 1)->error);
                        my $size = 8 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf;
                            my $n = sysread(SRC, $buf, $size);
                            sftp_error($ref, "Unable to read source: $!")
                                if (!defined $n);
                            defined sftp($host)->write($dst_fh, $buf) or
                                sftp_error($ref, "Unable to write destination: " .
                                    sftp($host, 1)->error);
                        }
                        #TODO: need to trunc if dst has more bytes than src
                    }
                    sftp($host)->close($dst_fh);
                } else {
                    sftp_error($ref, "Unable to open destination: " .
                        sftp($host, 1)->error);
                }
                close SRC;
            } else {
                sftp_error($ref, "Unable to open source: $!");
            }
        } elsif (!$rm && $op eq 'chattr') {
            my @attrs = split(/,/, $ref->{attrs});
            # don't return error for chown/chgrp since unlikely to succeed
            my $sattrs = Net::SFTP::Foreign::Attributes->new;
            $sattrs->set_ugid($attrs[1], $attrs[2]);
            sftp($host)->setstat($dst, $sattrs);

            $sattrs = Net::SFTP::Foreign::Attributes->new;
            $sattrs->set_perm($attrs[0]);
            $sattrs->set_amtime($attrs[3], $attrs[4]);
            sftp($host)->setstat($dst, $sattrs) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        }
    }
}

#########################
#### transport_rsync ####
#########################
sub transport_rsync {
    my ($args, $from, $files, $errs) = @_;
    my ($code, $code_text, $pid, $in, $out, $size);
    $from = "--files-from $from" if ($from);
    # copy inplace to avoid writing dot files in home directory
    # do not do this when whole files used for DMF
    $args .= " --inplace" if ($args !~ /-W/);
    eval {
        local $SIG{__WARN__} = sub {die};
        # use open3 to avoid executing a shell command based on the name
        # of a file being copied (which may contain metacharacters, etc.)
        # must keep write access to handle warnings/corruption
        $pid = open3($in, $out, $out,
            quotewords('\s+', 0, "rsync -l --chmod=u+rwX --stats $args $from $files"));
    };
    if ($@) {
        $code = 1;
        $code_text = "Unable to run rsync";
    } else {
        while (my $line = <$out>) {
            $line =~ s/\s*\r?\n$//;
            if ($line =~ /"([^"]+)"/) {
                my $file = $1;
                if (exists $errs->{$file}) {
                    sftp_error($errs->{$file}, $line);
                }
            } elsif ($line =~ /\(code\s+(\d+)\)/) {
                $code = $1;
                $code_text = $line;
            } elsif ($line =~ /Total bytes sent:\s*(\d+)/) {
                $size += $1;
            } elsif ($line =~ /Total bytes received:\s*(\d+)/) {
                $size += $1;
            }
        }
    }
    close $in;
    close $out;
    waitpid($pid, 0) if ($pid);

#TODO: why is code 23 ignored?  a non-existent file is a code 23 as well
    if (defined $code && $code != 23) {
        my $type = $code <= 5 ? "\\E" : "\\W";
        # set error/warning on all failures except partial transfers
        foreach my $ref (values %{$errs}) {
            $ref->{text} = "$type$code_text" if (!$ref->{text});
        }
    }
    return $size;
}

#############
#### vcd ####
#############
sub vcd {
    my ($ref, $host, $path, $copts) = @_;
    my $attrs = sftp($host)->stat($path);
    #TODO: pushd/popd?, set OLDPWD?
    $path =~ s/\/*$//;
    if (!$attrs) {
        sftp_echo($ref, "echo " . hostpath($host, $path) .
            ": No such file or directory");
    } elsif (!S_ISDIR($attrs->perm)) {
        sftp_echo($ref, "echo " . hostpath($host, $path) .
            ": Not a directory");
    } else {
        my $dir = dirname($sftp_sock) . "/empty";
        sftp_echo($ref, "builtin cd $dir; export PWD=" .
            hostpath($host, $path));
    }
}

################
#### vchgrp ####
################
sub vchgrp {
    return vchown(@_, 1);
}

################
#### vchmod ####
################
sub vchmod {
    my ($ref, $host, $path, $copts) = @_;
    #TODO: handle options/links/etc., ago+rwx syntax
    my $attrs = Net::SFTP::Foreign::Attributes->new;
    $attrs->set_perm(oct $copts->{-arg1});
    if (!sftp($host)->setstat($path, $attrs)) {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

################
#### vchown ####
################
sub vchown {
    my ($ref, $host, $path, $copts, $chgrp) = @_;
    #TODO: handle options/links/etc.
    if (!defined $copts->{-user} && !defined $copts->{-group}) {
        my ($user, $group);
        if ($chgrp) {
            $group = $copts->{-arg1};
        } else {
            if ($copts->{-arg1} =~ /(\w+)?:(\w+)/) {
                ($user, $group) = ($1, $2);
            } else {
                $user = $copts->{-arg1};
            }
        }
        if (defined $group) {
            if ($group !~ /^\d+$/) {
                # find remote group name in remote /etc/group
                my $fh = sftp($host)->open("/etc/group");
                while (<$fh>) {
                    if (/^$group:[^:]*:(\d+)/) {
                        $copts->{-group} = $1;
                        last;
                    }
                }
                close $fh;
                sftp_error($ref, "Invalid argument")
                    if (!defined $copts->{-group});
            } else {
                $copts->{-group} = $group;
            }
        }
        if (defined $user) {
            if ($user !~ /^\d+$/) {
                # find remote user name in remote /etc/group
                my $fh = sftp($host)->open("/etc/passwd");
                while (<$fh>) {
                    if (/^$user:[^:]*:(\d+)/) {
                        $copts->{-user} = $1;
                        last;
                    }
                }
                close $fh;
                sftp_error($ref, "Invalid argument")
                    if (!defined $copts->{-user});
            } else {
                $copts->{-user} = $user;
            }
        }
    }
    my $attrs = sftp($host)->stat($path);
    if (!$attrs) {
        sftp_error($ref, "No such file or directory");
    } else {
        my ($user, $group) = ($attrs->uid, $attrs->gid);
        $user = $copts->{-user} if (defined $copts->{-user});
        $group = $copts->{-group} if (defined $copts->{-group});
        $attrs->set_ugid($user, $group);
        sftp_error($ref, "Operation not permitted")
            if (!sftp($host)->setstat($path, $attrs));
    }
}

###################
#### vcomplete ####
###################
sub vcomplete {
    my ($ref, $host, $path, $copts) = @_;
    my ($tmp_fh, $tmp) = sftp_tmp();
    $path .= "/" if ($copts->{-arg} =~ /\/$/);
    my @link;
    my @glob = sftp($host)->glob("$path*", follow_links => 1,
        on_error => sub {push(@link, $_[1])});
    push(@glob, @link);
    foreach (@glob) {
        print $tmp_fh $copts->{-arg};
        print $tmp_fh substr($_->{filename}, length $path);
        print $tmp_fh "/" if (S_ISDIR($_->{a}->perm));
        print $tmp_fh "\n";
    }
    close $tmp_fh;
    sftp_cmd($ref, "sort", $tmp);
}

#############
#### vcp ####
#############
sub vcp {
    vmv(@_, 1);
}

#############
#### vdf ####
#############
sub vdf {
    my ($ref, $host, $path, $copts) = @_;
    if ($host eq 'localhost') {
        return if ($^O eq 'MSWin32');
        # collect disk space
        my ($pid, $in, $out);
        eval {
            local $SIG{__WARN__} = sub {die};
            # use 2s alarm in case df stalls
            local $SIG{ALRM} = sub {die};
            alarm 2;
            # use open3 to avoid executing a shell command based on the name
            # of a file being copied (which may contain metacharacters, etc.)
            alarm 0;
            $pid = open3($in, $out, $out, 'df', '-Pk', $path);
        };
        if (!$@) {
            <$out> if (scalar(@{$copts->{-argv}}) != 1);
            while (my $line = <$out>) {
                $line =~ s/\s*\r?\n$//;
                sftp_echo($ref, $line);
            }
        }
        close $in;
        close $out;
        waitpid($pid, 0) if ($pid);
    } else {
        my $df = sftp($host)->statvfs($path);
        if (defined $df && $copts->{i}) {
            sftp_echo($ref, "Filesystem\tInodes\t\tIUsed\tIFree\t\tIUse%  Mounted on")
                if (scalar(@{$copts->{-argv}}) == 1);
            sftp_echo($ref, "?\t\t$df->{files}\t" . ($df->{files} - $df->{ffree}) .
                "\t$df->{ffree}\t" . int(100 * ($df->{files} - $df->{ffree}) /
                $df->{files}) . "%\t$path");
        } elsif (defined $df) {
            sftp_echo($ref, "Filesystem\t1K-blocks\tUsed\t\tAvailable\tUse%  Mounted on")
                if (scalar(@{$copts->{-argv}}) == 1);
            my $s = $df->{bsize} / 1024.0;
            sftp_echo($ref, "?\t\t" . int($s * $df->{blocks}) . "\t" .
                int($s * ($df->{blocks} - $df->{bfree})) . "\t" .
                int($s * $df->{bfree}) . "\t" .
                int(100 * ($df->{blocks} - $df->{bfree}) /
                    $df->{blocks}) . "%\t$path");
        } else {
            sftp_error($ref, "Statvfs is not supported by the target sftp server");
        }
    }
}

#############
#### vdu ####
#############
sub vdu {
    my ($ref, $host, $path, $copts) = @_;
    my ($dcurr, $dmin, $dprev) = (0, $path =~ tr/\///, 0);
    my @dirs = ($path);
    my @sizes = (0);
    my %follow;
    $follow{follow_links} = 1 if ($copts->{L});
    sftp($host)->find($path,
        %follow,
        ordered => 1,
        wanted => sub {
            my $name = $_[1]->{filename};
            my $perm = $_[1]->{a}->perm;
            my $size = $_[1]->{a}->size;
            if (!$copts->{b}) {
                $size = int(($size + 1023) / 1024);
                if (S_ISDIR($perm)) {
                    $size = 4 * int($size / 4);
                } else {
                    $size = 4 * int(($size + 3) / 4);
                }
            }
            $dcurr = ($name =~ tr/\///) - $dmin;
            if (!$copts->{s}) {
                for (my $i = $dprev - 1; $i >= $dcurr; $i--) {
                    sftp_echo($ref, "$sizes[$i]\t$dirs[$i]");
                }
            }
            if (S_ISDIR($perm)) {
                $dirs[$dcurr] = $name;
                $sizes[$dcurr] = 0;
            } elsif ($copts->{a}) {
                sftp_echo($ref, "$size\t$name")
            }
            $sizes[$_] += $size for (0..$dcurr);
            $dprev = $dcurr;
            return undef;
        });
        sftp_echo($ref, "$sizes[0]\t$dirs[0]");
}

###############
#### vhead ####
###############
sub vhead {
    my ($ref, $host, $path, $copts) = @_;
    my $n = (grep(/^\d+$/, keys %{$copts}))[0];
    $n = 10 if (!defined $n);
    my $fh = sftp($host)->open($path);
    if ($fh) {
        my ($tmp_fh, $tmp) = sftp_tmp();
        while (<$fh>) {
            last if ($n-- <= 0);
            print $tmp_fh $_;
        }
        close $tmp_fh;
        close $fh;
        sftp_cmd($ref, "cat", $tmp);
    } else {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

#############
#### vln ####
#############
sub vln {
    my ($ref, $copts) = @_;
    #TODO: handle opts, -f, etc.
    # do not run original spliced command
    $copts->{-argc} = 0;
    my $dpath0 = pop @{$copts->{-argv}};
    (my $dhost, $dpath0) = hostpath($dpath0);
    if ($dhost ne 'localhost') {
        my $attrs = sftp($dhost)->stat($dpath0);
        foreach my $spath0 (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath0) 
                if ($attrs && S_ISDIR($attrs->perm));
            my ($shost, $spath) = hostpath($spath0);
            if ($shost ne 'localhost') {
                # link remote to remote
                if ($shost eq $dhost) {
                    sftp($dhost)->symlink($dpath, $spath);
                } else {
                    sftp($dhost)->symlink($dpath, $spath0);
                }
            } else {
                # link remote to local
                sftp_error($ref, "Cannot link remote file to local file");
            }
        }
    } else {
        # link local to remote
        foreach my $spath (@{$copts->{-argv}}) {
            next if (!hostpath($spath));
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) if (-d $dpath0);
            symlink($spath, $dpath);
        }
    }
}

#############
#### vls ####
#############
sub vls {
    my ($ref, $host, $path, $copts) = @_;
    my @glob;
    if ($copts->{d}) {
        @glob = sftp($host)->glob($path);
    } else {
        my @link;
        @glob = sftp($host)->glob($path, follow_links => 1,
            on_error => sub {push(@link, $_[1])});
        push(@glob, @link);
    }
    my $globc = scalar(@glob);
    if (!$globc) {
        sftp_error($ref, "/$host$path: No such file or directory");
    } elsif ($copts->{-vargc}) {
        #TODO: this is wrong when path is a file and not dir
        #      probably need to do ls all at once like cp/mv
        sftp_echo($ref, "");
        sftp_echo($ref, "/$host$path:");
    } elsif ($copts->{-argc} || $copts->{-argsleft} > 0) {
        #TODO: this is wrong when path is a file and not dir
        #      probably need to do ls all at once like cp/mv
        sftp_echo($ref, "/$host$path:");
    }
    $copts->{-vargc}++;
    my $cmd = (!$copts->{l} && !$copts->{1} ? "column" : "cat");
    my $tmp = sftp_tmp();
    if ($globc) {
        open(TMP, "|sort -k 9 -o $tmp");
        foreach (@glob) {
            next if (!$copts->{d} && S_ISDIR($_->{a}->perm));
            $_->{link} = sftp($host)->readlink($_->{filename})
                if ($copts->{l} && S_ISLNK($_->{a}->perm));
            print TMP sftp_ls($_, 0, $copts->{l}) . "\n";
        }
        close TMP;
        sftp_cmd($ref, $cmd, $tmp);
        $tmp = sftp_tmp();
    }
    open(TMP, "|sort -k 9 -o $tmp");
    if ($globc && !$copts->{d}) {
        @glob = sftp($host)->glob("$path/*");
        #TODO: empty directories do not show up
        my $dir;
        for (my $j = 0; $j < scalar(@glob); $j++) {
            my $tdir = dirname($glob[$j]->{filename});
            if ($tdir ne $dir) {
                $dir = $tdir;
                if ($j > 0) {
                    close TMP;
                    sftp_cmd($ref, $cmd, $tmp);
                    $tmp = sftp_tmp();
                    open(TMP, "|sort -k 9 -o $tmp");
                }
                if ($globc > 1) {
                    #TODO: this is wrong when path is a file and not dir
                    #      probably need to do ls all at once like cp/mv
                    sftp_echo($ref, "");
                    sftp_echo($ref, "$dir:");
                }
            }
            if ($copts->{l} && S_ISLNK($glob[$j]->{a}->perm)) {
                $glob[$j]->{link} = sftp($host)->readlink($glob[$j]->{filename});
            }
            print TMP sftp_ls($glob[$j], 1, $copts->{l}) . "\n";
        }
    }
    close TMP;
    sftp_cmd($ref, $cmd, $tmp);
}

################
#### vmkdir ####
################
sub vmkdir {
    my ($ref, $host, $path, $copts) = @_;
    my $attrs = sftp($host)->stat($path);
    if ($attrs && (!$copts->{-overwrite} || !S_ISDIR($attrs->perm))) {
        sftp_error($ref, "File exists");
    } elsif (!$attrs && !sftp($host)->mkdir($path)) {
        sftp_error($ref, "Permission denied");
    }
}

#############
#### vmv ####
#############
sub vmv {
    my ($ref, $copts, $cp) = @_;
    if (scalar(@{$copts->{-argv}}) == 1) {
        sftp_error($ref, "usage: " . ($cp ? "cp" : "mv") . " src ... dst");
        next;
    }
    my %shosts;
    my $dpath0 = pop @{$copts->{-argv}};
    (my $dhost, $dpath0) = hostpath($dpath0);
    if ($dhost ne 'localhost') {
        # do not run original spliced command
        $copts->{-argc} = 0;
        my $dattrs = sftp($dhost)->stat($dpath0);
        foreach my $spath (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) 
                if ($dattrs && S_ISDIR($dattrs->perm));
            (my $shost, $spath) = hostpath($spath);
            if ($shost ne 'localhost') {
                # copy remote to remote
                if ($shost eq $dhost) {
                    #TODO: check is src/dst host are the same
                    #so rename instead
                } else {
                    $shosts{$shost} = 1;
                }
                my $tmp = sftp_tmp();
                my $sattrs = sftp($shost)->stat($spath);
    #TODO: need a check about copying multiple files to a file, etc.
                if (!$sattrs) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (S_ISDIR($sattrs->perm)) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rget', $shost, $spath, $tmp, {});
                        transport('rput', $dhost, $tmp, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', $shost, $spath, undef, {}) if (!$cp);
                        transport('rrm', 'localhost', $tmp, undef, {});
                    }
                } elsif (S_ISREG($sattrs->perm) || S_ISLNK($sattrs->perm)) {
                    transport('get', $shost, $spath, $tmp, {});
                    transport('put', $dhost, $tmp, $dpath, {});
                    #TODO: do error checking before rm
                    transport('rm', $shost, $spath, undef, {}) if (!$cp);
                    transport('rm', 'localhost', $tmp, undef, {});
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
                #TODO: warn on non-{dir|reg|lnk}
            } else {
                # copy local to remote
                if (! -e $spath) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (-d $spath) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rput', $dhost, $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', 'localhost', $spath, undef, {})
                            if (!$cp);
                    }
                } elsif (-f $spath || -l $spath) {
                    transport('put', $dhost, $spath, $dpath, {});
                    transport('rm', 'localhost', $spath, undef, {}) if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            }
        }
        #TODO: warn if only one arg for general case?
    } else {
        # original spliced command needs at least two args
        $copts->{-argc} = 0 if ($copts->{-argc} == 1);
        foreach my $spath (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) if (-d $dpath0);
            (my $shost, $spath) = hostpath($spath);
            if ($shost ne 'localhost') {
                # copy remote to local
                $shosts{$shost} = 1;
                my $sattrs = sftp($shost)->stat($spath);
                if (!$sattrs) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (S_ISDIR($sattrs->perm)) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rget', $shost, $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', $shost, $spath, undef, {}) if (!$cp);
                    }
                } elsif (S_ISREG($sattrs->perm) || S_ISLNK($sattrs->perm)) {
                    transport('get', $shost, $spath, $dpath, {});
                    #TODO: do error checking before rm
                    transport('rm', $shost, $spath, undef, {}) if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            } else {
                # copy local to local
                if (! -e $spath) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (-d $spath) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rput', 'localhost', $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', 'localhost', $spath, undef, {})
                            if (!$cp);
                    }
                } elsif (-f $spath || -l $spath) {
                    transport('put', 'localhost', $spath, $dpath, {});
                    transport('rm', 'localhost', $spath, undef, {})
                        if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            }
        }
    }
    transport('end', 'localhost');
    transport('end', $_) foreach (keys %shosts);
    transport('end', $dhost);
#TODO: this is a problem because mkdir needs to be executed first on
#      localhost but rm's needs to be last ... probably need 2 stages
# FIXED BUT NOT TESTED
    transport('end', 'localhost', 1);
}

#############
#### vrm ####
#############
sub vrm {
    my ($ref, $host, $path, $copts) = @_;
    if ($copts->{r}) {
        sftp_error($ref, sftp($host, 1)->error)
            if (!sftp($host)->rremove($path));
    } else {
        sftp_error($ref, sftp($host, 1)->error)
            if (!sftp($host)->remove($path));
    }
}

################
#### vrmdir ####
################
sub vrmdir {
    my ($ref, $host, $path, $copts) = @_;
    #TODO: directory does not exist
    sftp_error($ref, "Directory not empty or permission denied")
        if (!sftp($host)->rmdir($path));
}

###############
#### vtail ####
###############
sub vtail {
    my ($ref, $host, $path, $copts) = @_;
    my $n = (grep(/^\d+$/, keys %{$copts}))[0];
    $n = 10 if (!defined $n);
    my $fh = sftp($host)->open($path);
    if ($fh) {
        my $attrs = sftp($host)->stat($path);
        my ($seek, $block, $nl, $i, $line) = ($attrs->size, $n * 80, 0, 1);
        do {
            $seek -= $block * $i++;
            $seek = 0 if ($seek < 0);
            seek($fh, $seek, 0);
            read($fh, $line, $block);
            $nl++ while ($line =~ /\n/gs);
            my $index = 0;
            while ($nl > $n) {
                $index = index($line, "\n", $index) + 1;
                $nl--;
            }
            $seek += $index;
        } while ($seek > 0 && $nl < $n);
        my ($tmp_fh, $tmp) = sftp_tmp();
        seek($fh, $seek, 0);
        print $tmp_fh $_ while (<$fh>);
        close $tmp_fh;
        close $fh;
        sftp_cmd($ref, "cat", $tmp);
    } else {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

##############
#### vtee ####
##############
sub vtee {
    my ($ref, $copts) = @_;
    # do not run original spliced command
    $copts->{-argc} = 0;
    my @fhs;
    my $append = ($copts->{a} ? ">" : "");
    my $flags = SFTP_WRITE | SFTP_CREAT;
    $flags |= SFTP_TRUNC if (!$copts->{a});
    foreach (@{$copts->{-argv}}) {
        my $fh;
        my ($host, $path) = hostpath($_);
        if ($host ne 'localhost') {
            $fh = sftp($host)->open($path, $flags);
            seek($fh, 0, 2) if ($copts->{a});
        } else {
            open($fh, "$append>", $_);
        }
        push(@fhs, $fh);
    }
#TODO: tee hangs to remote file if input from another vfs command
    while (my $line = <$ref>) {
        print $_ $line foreach (@fhs);
    }
    close $_ foreach (@fhs);
}

###############
#### vtest ####
###############
sub vtest {
    my ($ref, $host, $path, $copts) = @_;
    my $true = 0;
    my $attrs = sftp($host)->stat($path);
    # can't implement -x, -G, or -O w/o effective uid/gid
    if ($attrs && (
            $copts->{b} && S_ISBLK($attrs->perm) ||
            $copts->{c} && S_ISCHR($attrs->perm) ||
            $copts->{d} && S_ISDIR($attrs->perm) ||
            $copts->{e} ||
            $copts->{f} && S_ISREG($attrs->perm) ||
            $copts->{g} && (S_ISGID & $attrs->perm) ||
            $copts->{h} && S_ISLNK($attrs->perm) ||
            $copts->{k} && (S_ISVTX & $attrs->perm) || 
            $copts->{p} && S_ISFIFO($attrs->perm) && !S_ISSOCK($attrs->perm) ||
            $copts->{s} && $attrs->size > 0 ||
            $copts->{u} && (S_ISUID & $attrs->perm) ||
#TODO: this (maybe others) wrong because stat will never return a symlink
            $copts->{L} && S_ISLNK($attrs->perm) ||
            $copts->{S} && S_ISSOCK($attrs->perm))) {
        $true = 1;
    } elsif ($attrs && $copts->{r}) {
        my $fh = sftp($host)->open($path);
        if ($fh) {
            close $fh;
            $true = 1;
        }
    } elsif ($attrs && $copts->{w}) {
        my $fh = sftp($host)->open($path, SFTP_WRITE);
        if ($fh) {
            close $fh;
            $true = 1;
        }
    }
    sftp_cmd($ref, $true ? "true" : "false");
}

################
#### vtouch ####
################
sub vtouch {
    my ($ref, $host, $path, $copts) = @_;
    my $attrs = sftp($host)->stat($path);
    if (!$attrs) {
        my $fh = sftp($host)->open($path, SFTP_CREAT | SFTP_WRITE);
        if (!$fh) {
            sftp_error($ref, "Permission denied");
        } else {
            close $fh;
        }
    } else {
        my $time = time;
        my $atime = ($copts->{a} || !$copts->{m} ? $time : $attrs->atime);
        my $mtime = ($copts->{m} || !$copts->{a} ? $time : $attrs->mtime);
        $attrs->set_amtime($atime, $mtime);
        sftp_error($ref, "Permission denied")
            if (!sftp($host)->setstat($path, $attrs));
    }
}

##########################
#### File::Spec::Link ####
##########################
# Copyright 2003, 2005, 2006, 2007 by Robin Barker (Robin.Barker@npl.co.uk)
# License: Perl Artistic License
package File::Spec::Link;

use strict;
use warnings;

use File::Spec ();
use base q(File::Spec); 

our $VERSION = 0.072;

# over-ridden class method - just a debugging wrapper
# 
sub canonpath { 
    my($spec, $path) = @_;
    return $spec->SUPER::canonpath($path) if $path;
    require Carp;
    Carp::cluck( "canonpath: ", 
		defined $path ? "empty path" : "path undefined"  
    );
    return $path;
}
sub catdir { my $spec = shift; return @_ ? $spec->SUPER::catdir(@_) : $spec->curdir }

# new class methods - implemented via objects
# 
sub linked { 
    my $self = shift -> new(@_); 
    return unless $self -> follow; 
    return $self -> path; 
}
sub resolve { 
    my $self = shift -> new(@_); 
    return unless $self -> resolved; 
    return $self -> path; 
}
sub resolve_all { 
    my $self = shift -> new(@_); 
    # PZK 5/07/09: return original if url
    return $_[0] if ($_[0] =~ /^(?:file:|[a-z]+:\/\/)/);
    return unless $self -> resolvedir; 
    # PZK 2/12/09: add trailing /, if originally given, for completion
    return $self -> path . (($_[0] =~ /\/$/) ? "/" : "");
#    return $self -> path; 
}
sub relative_to_file { 
    my($spec, $path) = splice @_, 0, 2;
    my $self = $spec -> new(@_); 
    return unless $self -> relative($path);
    return $self -> path;
}
sub chopfile {
    my $self = shift -> new(@_);
    return $self -> path if length($self -> chop); 
    return
}

# other new class methods - implemented via Cwd
# 
sub full_resolve {
    my($spec, $file) = @_;
    my $path = $spec->resolve_path($file);
    return defined $path ? $path : $spec->resolve_all($file);
}

sub resolve_path {
    my($spec, $file) = @_;
    my $path = do {
	local $SIG{__WARN__} = sub { 
	    if ($_[0] =~ /^opendir\b/			and
		$_[0] =~ /\bNot\s+a\s+directory\b/	and
	    	$Cwd::VERSION < 2.18		 	and
		not -d $file)
	    {
		warn <<WARN;
Cwd::abs_path() only works on directories, not: $file
Use Cwd v2.18 or later
WARN
	    }
	    else {
		warn $_[0]
	    }
	};
	eval { require Cwd } && Cwd::abs_path($file) 
    };
    return unless $path; 
    return $spec->file_name_is_absolute($file)
	    ? $path : $spec->abs2rel($path);
} 

# old class method - not needed
# 
sub splitlast { 
    my $self = shift -> new(@_);
    my $last_path = $self -> chop;
    return ($self -> path, $last_path);
}

# object methods: 
# 	constructor methods	new
# 	access methods		path, canonical, vol, dir 
# 	updating methods	add, pop, push, split, chop
# 				relative, follow, resolved, resolvedir  

sub new { 
    my $self = bless { }, shift; 
    $self -> split(shift) if @_; 
    return $self; 
}
sub path { 
    my $self = shift; 
    return $self -> catpath( $self->vol, $self->dir, q{} ); 
}
sub canonical { my $self = shift; return $self -> canonpath( $self -> path ); }
sub vol { my $vol = shift->{vol}; return defined $vol ? $vol : q{} } 
sub dir { my $self = shift; return $self -> catdir( $self -> dirs ); }
sub dirs { my $dirs = shift->{dirs}; return $dirs ? @{$dirs} : () }
	
sub add {
    my($self, $file) = @_;
    if( $file eq $self -> curdir ) { }
    elsif( $file eq $self -> updir ) { $self -> pop }
    else { $self -> push($file); }
    return;
}
sub pop {
    my $self = shift;
    my @dirs = $self -> dirs;
    if( not @dirs or $dirs[-1] eq $self -> updir ) {
	push @{$self->{dirs}}, $self -> updir;
    }
    elsif( length $dirs[-1] and $dirs[-1] ne $self -> curdir) {
	CORE::pop @{$self->{dirs}}
    }	
    else {
	require Carp;
	Carp::cluck( "Can't go up from ", 
			length $dirs[-1] ? $dirs[-1]: "empty dir"
	);
    }
    return;
}

sub push {
    my $self = shift;
    my $file = shift;
    CORE::push @{$self->{dirs}}, $file if length $file;
    return;
}
sub split {
    my($self, $path) = @_;
    my($vol, $dir, $file) = $self->splitpath($path, 1);
    $self->{vol} = $vol;
    $self->{dirs} = [ $self->splitdir($dir) ];
    $self->push($file);
    return;
}
sub chop {
    my $self = shift;
    my $dirs = $self->{dirs};
    my $file = '';
    while( @$dirs ) {
	last if @$dirs == 1 and not length $dirs->[0];	# path = '/'
	last if length($file = CORE::pop @$dirs);
    }
    return $file;    
}    
    
sub follow {
    my $self = shift;
    my $path = $self -> path;
    my $link = readlink $self->path;
    return $self->relative($link) if defined $link;
    require Carp;
    Carp::confess(
	"Can't readlink ", $self->path, 
    	" : ", 
	(-l $self->path ? "but it is" : "not"), 
	" a link"
    );
}
 
sub relative {
    my($self, $path) = @_;
    unless( $self->file_name_is_absolute($path) ) {
	return unless length($self->chop);
	$path = $self->catdir($self->path, $path);
    }
    # what we want to do here is just set $self->{path}
    # to be read by $self->path; but would need to 
    # unset $self->{path} whenever it becomes invalid
    $self->split($path);
    return 1;
}

sub resolved {
    my $self = shift;
    my $seen = @_ ? shift : {};
    while( -l $self->path ) {
	return if $seen->{$self->canonical}++;
	return unless $self->follow;
    }
    return 1;
}

sub resolvedir {
    my $self = shift;
    my $seen = @_ ? shift : {};
    my @path;
    while( 1 ) {
	return unless $self->resolved($seen);
	my $last = $self->chop;
	last unless length $last;
	unshift @path, $last;
    }
    $self->add($_) for @path;    
    return 1;
}

1;

package main;

############################
#### Net::SFTP::Foreign ####
############################
# Copyright (c) 2005-2010 Salvador Fandin~o (sfandino@yahoo.com).
# Copyright (c) 2001 Benjamin Trott, Copyright (c) 2003 David Rolsky.
# _glob_to_regex method based on code (c) 2002 Richard Clamp.
# License: Perl Artistic License

sub sftp_require {
    my $dir = shift;
    # TODO: remember to always strip out Encode portions (search Encode)
    # delete from here to end and insert sftpinc.pl output
    mkdir "$dir/Net";
    mkdir "$dir/Net/SFTP";
    open(FILE, ">$dir/Net/SFTP/Foreign.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign;

our $VERSION = '1.69';

use strict;
use warnings;
use warnings::register;

use Carp qw(carp croak);

use Symbol ();
use Errno ();
use Fcntl;

# we make $Net::SFTP::Foreign::Helpers::debug an alias for
# $Net::SFTP::Foreign::debug so that the user can set it without
# knowing anything about the Helpers package!
our $debug;
BEGIN { *Net::SFTP::Foreign::Helpers::debug = \$debug };
use Net::SFTP::Foreign::Helpers qw(_is_reg _is_lnk _is_dir _debug
                                   _sort_entries _gen_wanted
                                   _gen_converter _hexdump
                                   _ensure_list _catch_tainted_args
                                   _file_part);
use Net::SFTP::Foreign::Constants qw( :fxp :flags :att
				      :status :error
				      SSH2_FILEXFER_VERSION );
use Net::SFTP::Foreign::Attributes;
use Net::SFTP::Foreign::Buffer;
require Net::SFTP::Foreign::Common;
our @ISA = qw(Net::SFTP::Foreign::Common);

our $dirty_cleanup;
my $windows;

BEGIN {
    $windows = $^O =~ /Win(?:32|64)/;

    if ($^O =~ /solaris/i) {
	$dirty_cleanup = 1 unless defined $dirty_cleanup;
    }
}

sub _next_msg_id { shift->{_msg_id}++ }

use constant _empty_attributes => Net::SFTP::Foreign::Attributes->new;

sub _queue_new_msg {
    my $sftp = shift;
    my $code = shift;
    my $id = $sftp->_next_msg_id;
    my $msg = Net::SFTP::Foreign::Buffer->new(int8 => $code, int32 => $id, @_);
    $sftp->_queue_msg($msg);
    return $id;
}

sub _queue_msg {
    my ($sftp, $buf) = @_;

    my $bytes = $buf->bytes;
    my $len = length $bytes;

    if ($debug and $debug & 1) {
	$sftp->{_queued}++;
	_debug(sprintf("queueing msg len: %i, code:%i, id:%i ... [$sftp->{_queued}]",
		       $len, unpack(CN => $bytes)));

        $debug & 16 and _hexdump(pack('N', length($bytes)) . $bytes);
    }

    $sftp->{_bout} .= pack('N', length($bytes));
    $sftp->{_bout} .= $bytes;
}


sub _do_io { $_[0]->{_backend}->_do_io(@_) }

sub _conn_lost {
    my ($sftp, $status, $err, @str) = @_;

    $debug and $debug & 32 and _debug("_conn_lost");

    $sftp->{_status} or
	$sftp->_set_status(defined $status ? $status : SSH2_FX_CONNECTION_LOST);

    $sftp->{_error} or
	$sftp->_set_error((defined $err ? $err : SFTP_ERR_CONNECTION_BROKEN),
			  (@str ? @str : "Connection to remote server is broken"));

    undef $sftp->{_connected};
}

sub _conn_failed {
    my $sftp = shift;
    $sftp->_conn_lost(SSH2_FX_NO_CONNECTION,
                      SFTP_ERR_CONNECTION_BROKEN,
                      @_)
	unless $sftp->error;
}

sub _get_msg {
    my $sftp = shift;

    $debug and $debug & 1 and _debug("waiting for message... [$sftp->{_queued}]");

    unless ($sftp->_do_io($sftp->{_timeout})) {
	$sftp->_conn_lost(undef, undef, "Connection to remote server stalled");
	return undef;
    }

    my $bin = \$sftp->{_bin};
    my $len = unpack N => substr($$bin, 0, 4, '');
    my $msg = Net::SFTP::Foreign::Buffer->make(substr($$bin, 0, $len, ''));

    if ($debug and $debug & 1) {
	$sftp->{_queued}--;
        my ($code, $id, $status) = unpack( CNN => $$msg);
	$id = '-' if $code == SSH2_FXP_VERSION;
        $status = '-' unless $code == SSH2_FXP_STATUS;
	_debug(sprintf("got it!, len:%i, code:%i, id:%s, status: %s",
                       $len, $code, $id, $status));
        $debug & 8 and _hexdump($$msg);
    }

    return $msg;
}

sub _croak_bad_options {
    if (@_) {
        my $s = (@_ > 1 ? 's' : '');
        croak "Invalid option$s '" . CORE::join("', '", @_) . "' or bad combination of options";
    }
}

sub _fs_encode {
    my ($sftp, $path) = @_;
    $path;
}

sub _fs_decode {
    my ($sftp, $path) = @_;
    $path;
}

sub new {
    ${^TAINT} and &_catch_tainted_args;

    my $class = shift;
    unshift @_, 'host' if @_ & 1;
    my %opts = @_;

    my $sftp = { _msg_id => 0,
		 _bout => '',
		 _bin => '',
		 _connected => 1,
		 _queued => 0 };

    bless $sftp, $class;

    $sftp->_clear_error_and_status;

    my $backend = delete $opts{backend};
    unless (ref $backend) {
	$backend = ($windows ? 'Windows' : 'Unix')
	    unless (defined $backend);
	$backend =~ /^\w+$/
	    or croak "Bad backend name $backend";
	my $backend_class = "Net::SFTP::Foreign::Backend::$backend";
	eval "require $backend_class; 1"
	    or croak "Unable to load backend $backend: $@";
	$backend = $backend_class->_new($sftp, \%opts);
    }
    $sftp->{_backend} = $backend;

    my %defs = $backend->_defaults;

    $sftp->{_autodie} = delete $opts{autodie};
    $sftp->{_block_size} = delete $opts{block_size} || $defs{block_size} || 32*1024;
    $sftp->{_queue_size} = delete $opts{queue_size} || $defs{queue_size} || 32;
    $sftp->{_read_ahead} = $defs{read_ahead} || $sftp->{_block_size} * 4;
    $sftp->{_write_delay} = $defs{write_delay} || $sftp->{_block_size} * 8;
    $sftp->{_autoflush} = delete $opts{autoflush};
    $sftp->{_late_set_perm} = delete $opts{late_set_perm};
    $sftp->{_dirty_cleanup} = delete $opts{dirty_cleanup};

    $sftp->{_timeout} = delete $opts{timeout};
    defined $sftp->{_timeout} and $sftp->{_timeout} <= 0 and croak "invalid timeout";

    $sftp->{_fs_encoding} = delete $opts{fs_encoding};
    if (defined $sftp->{_fs_encoding}) {
        $] < 5.008
            and carp "fs_encoding feature is not supported in this perl version $]";
    }
    else {
        $sftp->{_fs_encoding} = 'utf8';
    }

    $sftp->autodisconnect(delete $opts{autodisconnect});

    $backend->_init_transport($sftp, \%opts);
    %opts and _croak_bad_options(keys %opts);

    $sftp->_init unless $sftp->error;
    $backend->_after_init($sftp);
    $sftp
}

sub autodisconnect {
    my ($sftp, $ad) = @_;
    if (defined $ad and $ad != 1) {
        if ($ad == 0) {
            $sftp->{_disconnect_by_pid} = -1;
        }
        elsif ($ad == 2) {
            $sftp->{_disconnect_by_pid} = $$;
        }
        else {
            croak "bad value '$ad' for autodisconnect";
        }
    }
    1;
}

sub disconnect {
    my $sftp = shift;
    my $pid = $sftp->{pid};

    $debug and $debug & 4 and _debug("$sftp->disconnect called (ssh pid: ".($pid||'').")");

    $sftp->_conn_lost;

    if (defined $pid) {
        close $sftp->{ssh_out} if (defined $sftp->{ssh_out} and not $sftp->{_ssh_out_is_not_dupped});
        close $sftp->{ssh_in} if defined $sftp->{ssh_in};
        if ($windows) {
	    kill KILL => $pid
                and waitpid($pid, 0);
        }
        else {
	    my $dirty = ( defined $sftp->{_dirty_cleanup}
			  ? $sftp->{_dirty_cleanup}
			  : $dirty_cleanup );

	    if ($dirty or not defined $dirty) {
		for my $sig (($dirty ? () : 0), qw(TERM TERM KILL KILL)) {
		    $sig and kill $sig, $pid;

		    my $except;
		    {
			local ($@, $SIG{__DIE__}, $SIG{__WARN__});
			eval {
			    local $SIG{ALRM} = sub { die "timeout\n" };
			    alarm 8;
			    waitpid($pid, 0);
			    alarm 0;
			};
			$except = $@;
		    }
		    if ($except) {
			next if $except =~ /^timeout/;
			die $except;
		    }
		    last;
		}
	    }
	    else {
		while (1) {
		    last if waitpid($pid, 0) > 0;
		    if ($! != Errno::EINTR) {
			warn "internal error: unexpected error in waitpid($pid): $!"
			    if $! != Errno::ECHILD;
			last;
		    }
		}
	    }
        }
    }
    1
}

sub DESTROY {
    local ($?, $!, $@);

    my $sftp = shift;
    my $dbpid = $sftp->{_disconnect_by_pid};

    $debug and $debug & 4 and _debug("$sftp->DESTROY called (current pid: $$, disconnect_by_pid: ".($dbpid||'').")");

    $sftp->disconnect if (!defined $dbpid or $dbpid == $$);
}

sub _init {
    my $sftp = shift;
    $sftp->_queue_msg( Net::SFTP::Foreign::Buffer->new(int8 => SSH2_FXP_INIT,
						       int32 => SSH2_FILEXFER_VERSION));

    if (my $msg = $sftp->_get_msg) {
	my $type = $msg->get_int8;
	if ($type == SSH2_FXP_VERSION) {
	    my $version = $msg->get_int32;

	    $sftp->{server_version} = $version;
            $sftp->{server_extensions} = {};
            while (length $$msg) {
                my $key = $msg->get_str;
                my $value = $msg->get_str;
                $sftp->{server_extensions}{$key} = $value;
            }

	    return $version;
	}

	$sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
			  SFTP_ERR_REMOTE_BAD_MESSAGE,
			  "bad packet type, expecting SSH2_FXP_VERSION, got $type");
    }
    elsif ($sftp->status == SSH2_FX_CONNECTION_LOST
	   and $sftp->{_password_authentication}
	   and $sftp->{_password_sent}) {
	$sftp->_set_error(SFTP_ERR_PASSWORD_AUTHENTICATION_FAILED,
			  "Password authentication failed or connection lost");
    }
    return undef;
}

sub server_extensions { %{shift->{server_extensions}} }

sub _check_extension {
    my ($sftp, $name, $version, $error, $errstr) = @_;
    my $ext = $sftp->{server_extensions}{$name};
    return 1 if (defined $ext and $ext == $version);

    $sftp->_set_status(SSH2_FX_OP_UNSUPPORTED);
    $sftp->_set_error($error, "$errstr: extended operation not supported by server");
    return undef;
}

# helper methods:
sub _get_msg_and_check {
    my ($sftp, $etype, $eid, $err, $errstr) = @_;
    my $msg = $sftp->_get_msg;
    if ($msg) {
	my $type = $msg->get_int8;
	my $id = $msg->get_int32;

	$sftp->_clear_error_and_status;

	if ($id != $eid) {
	    $sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
			      SFTP_ERR_REMOTE_BAD_MESSAGE,
			      $errstr, "bad packet sequence, expected $eid, got $id");
	    return undef;
	}

	if ($type != $etype) {
	    if ($type == SSH2_FXP_STATUS) {
                my $code = $msg->get_int32;
                my $str = $msg->get_str;
		my $status = $sftp->_set_status($code, (defined $str ? $str : ()));
		$sftp->_set_error($err, $errstr, $status);
	    }
	    else {
		$sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
				  SFTP_ERR_REMOTE_BAD_MESSAGE,
				  $errstr, "bad packet type, expected $etype packet, got $type");	
	    }
	    return undef;
	}
    }
    $msg;
}

# reads SSH2_FXP_HANDLE packet and returns handle, or undef on failure
sub _get_handle {
    my ($sftp, $eid, $error, $errstr) = @_;
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_HANDLE, $eid,
					    $error, $errstr)) {
	return $msg->get_str;
    }
    return undef;
}

sub _rid {
    my ($sftp, $rfh) = @_;
    my $rid = $rfh->_rid;
    unless (defined $rid) {
	$sftp->_set_error(SFTP_ERR_REMOTE_ACCESING_CLOSED_FILE,
			  "Couldn't access a file that has been previosly closed");
    }
    $rid
}

sub _rfid {
    $_[1]->_check_is_file;
    &_rid;
}

sub _rdid {
    $_[1]->_check_is_dir;
    &_rid;
}

sub _queue_rid_request {
    my ($sftp, $code, $fh, $attrs) = @_;
    my $rid = $sftp->_rid($fh);
    return undef unless defined $rid;

    $sftp->_queue_new_msg($code, str => $rid,
			 (defined $attrs ? (attr => $attrs) : ()));
}

sub _queue_rfid_request {
    $_[2]->_check_is_file;
    &_queue_rid_request;
}

sub _queue_rdid_request {
    $_[2]->_check_is_dir;
    &_queue_rid_request;
}

sub _queue_str_request {
    my($sftp, $code, $str, $attrs) = @_;
    $sftp->_queue_new_msg($code, str => $str,
			 (defined $attrs ? (attr => $attrs) : ()));
}

sub _check_status_ok {
    my ($sftp, $eid, $error, $errstr) = @_;
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_STATUS, $eid,
					    $error, $errstr)) {
	my $status = $sftp->_set_status($msg->get_int32, $msg->get_str);
	return 1 if $status == SSH2_FX_OK;

	$sftp->_set_error($error, $errstr, $status);
    }
    return undef;
}

sub setcwd {
    @_ <= 2 or croak 'Usage: $sftp->setcwd($path)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $cwd) = @_;
    $sftp->_clear_error_and_status;

    if (defined $cwd) {
        $cwd = $sftp->realpath($cwd);
        return undef unless defined $cwd;
	my $a = $sftp->stat($cwd)
	    or return undef;
	if (_is_dir($a->perm)) {
	    return $sftp->{cwd} = $cwd;
	}
	else {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$cwd' is not a directory");
	    return undef;
	}
    }
    else {
        delete $sftp->{cwd};
        return $sftp->cwd if defined wantarray;
    }
}

sub cwd {
    @_ == 1 or croak 'Usage: $sftp->cwd()';

    my $sftp = shift;
    return defined $sftp->{cwd} ? $sftp->{cwd} : $sftp->realpath('');
}

## SSH2_FXP_OPEN (3)
# returns handle on success, undef on failure
sub open {
    (@_ >= 2 and @_ <= 4)
	or croak 'Usage: $sftp->open($path [, $flags [, $attrs]])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $flags, $a) = @_;
    $path = $sftp->_rel2abs($path);
    defined $flags or $flags = SSH2_FXF_READ;
    defined $a or $a = Net::SFTP::Foreign::Attributes->new;
    my $id = $sftp->_queue_new_msg(SSH2_FXP_OPEN,
                                   str => $sftp->_fs_encode($path),
                                   int32 => $flags, attr => $a);

    my $rid = $sftp->_get_handle($id,
				SFTP_ERR_REMOTE_OPEN_FAILED,
				"Couldn't open remote file '$path'");

    if ($debug and $debug & 2) {
        _debug("new remote file '$path' open, rid:");
        _hexdump($rid);
    }

    defined $rid
	or return undef;

    my $fh = Net::SFTP::Foreign::FileHandle->_new_from_rid($sftp, $rid);
    $fh->_flag(append => 1) if ($flags & SSH2_FXF_APPEND);

    $fh;
}

## SSH2_FXP_OPENDIR (11)
sub opendir {
    @_ == 2 or croak 'Usage: $sftp->opendir($path)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my $path = shift;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_OPENDIR, $sftp->_fs_encode($path), @_);
    my $rid = $sftp->_get_handle($id, SFTP_ERR_REMOTE_OPENDIR_FAILED,
				 "Couldn't open remote dir '$path'");

    if ($debug and $debug & 2) {
        _debug("new remote dir '$path' open, rid:");
        _hexdump($rid);
    }

    defined $rid
	or return undef;

    Net::SFTP::Foreign::DirHandle->_new_from_rid($sftp, $rid, 0)
}

## SSH2_FXP_READ (4)
# returns data on success undef on failure
sub sftpread {
    (@_ >= 3 and @_ <= 4)
	or croak 'Usage: $sftp->sftpread($fh, $offset [, $size])';

    my ($sftp, $rfh, $offset, $size) = @_;

    unless ($size) {
	return '' if defined $size;
	$size = $sftp->{_block_size};
    }

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
				  int64 => $offset, int32 => $size);

    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $id,
					    SFTP_ERR_REMOTE_READ_FAILED,
					    "Couldn't read from remote file")) {
	return $msg->get_str;
    }
    return undef;
}

## SSH2_FXP_WRITE (6)
# returns true on success, undef on failure
sub sftpwrite {
    @_ == 4 or croak 'Usage: $sftp->sftpwrite($fh, $offset, $data)';

    my ($sftp, $rfh, $offset) = @_;
    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;
    utf8::downgrade($_[3], 1) or croak "wide characters found in data";

    my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
				  int64 => $offset, str => $_[3]);

    if ($sftp->_check_status_ok($id,
				SFTP_ERR_REMOTE_WRITE_FAILED,
				"Couldn't write to remote file")) {
	return 1;
    }
    return undef;
}

sub seek {
    (@_ >= 3 and @_ <= 4)
	or croak 'Usage: $sftp->seek($fh, $pos [, $whence])';

    my ($sftp, $rfh, $pos, $whence) = @_;
    $sftp->flush($rfh) or return undef;

    $whence ||= 0;

    if ($whence == 0) {
	return $rfh->_pos($pos)
    }
    elsif ($whence == 1) {
	return $rfh->_inc_pos($pos)
    }
    elsif ($whence == 2) {
	if (my $a = $sftp->fstat($rfh)) {
	    return $rfh->_pos($pos + $a->size);
	}
	else {
	    return undef;
	}
    }
    else {
	croak "invalid whence argument";
    }
}

sub tell {
    @_ == 2 or croak 'Usage: $sftp->tell($fh)';

    my ($sftp, $rfh) = @_;
    return $rfh->_pos + length ${$rfh->_bout};
}

sub eof {
    @_ == 2 or croak 'Usage: $sftp->eof($fh)';

    my ($sftp, $rfh) = @_;
    $sftp->_fill_read_cache($rfh, 1);
    return length(${$rfh->_bin}) == 0
}

sub _write {
    my ($sftp, $rfh, $off, $cb) = @_;

    $sftp->_clear_error_and_status;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $qsize = $sftp->{_queue_size};

    my @msgid;
    my @written;
    my $written = 0;
    my $end;

    while (!$end or @msgid) {
	while (!$end and @msgid < $qsize) {
	    my $data = $cb->();
	    if (defined $data and length $data) {
		my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
					      int64 => $off + $written, str => $data);
		push @written, $written;
		$written += length $data;
		push @msgid, $id;
	    }
	    else {
		$end = 1;
	    }
	}

	my $eid = shift @msgid;
	my $last = shift @written;
	unless ($sftp->_check_status_ok($eid,
					SFTP_ERR_REMOTE_WRITE_FAILED,
					"Couldn't write to remote file")) {

	    # discard responses to queued requests:
	    $sftp->_get_msg for @msgid;
	    return $last;
	}
    }

    return $written;
}

sub write {
    @_ == 3 or croak 'Usage: $sftp->write($fh, $data)';

    my ($sftp, $rfh) = @_;
    $sftp->flush($rfh, 'in') or return undef;
    utf8::downgrade($_[2], 1) or croak "wide characters found in data";
    my $datalen = length $_[2];
    my $bout = $rfh->_bout;
    $$bout .= $_[2];
    my $len = length $$bout;

    $sftp->flush($rfh, 'out')
	if ($len >= $sftp->{_write_delay} or ($len and $sftp->{_autoflush} ));

    return $datalen;
}

sub flush {
    (@_ >= 2 and @_ <= 3)
	or croak 'Usage: $sftp->flush($fh [, $direction])';

    my ($sftp, $rfh, $dir) = @_;
    $dir ||= '';

    if ($dir ne 'out') { # flush in!
	${$rfh->_bin} = '';
    }

    if ($dir ne 'in') { # flush out!
	my $bout = $rfh->_bout;
	my $len = length $$bout;
	if ($len) {
	    my $start;
	    my $append = $rfh->_flag('append');
	    if ($append) {
		my $attr = $sftp->fstat($rfh)
		    or return undef;
		$start = $attr->size;
	    }
	    else {
		$start = $rfh->_pos;
		${$rfh->_bin} = '';
	    }
	    my $off = 0;
	    my $written = $sftp->_write($rfh, $start,
					sub {
					    my $data = substr($$bout, $off, $sftp->{_block_size});
					    $off += length $data;
					    $data;
					} );
	    $rfh->_inc_pos($written)
		unless $append;

	    substr($$bout, 0, $written, '');
	    $written == $len or return undef;
	}
    }
    1;
}

sub _fill_read_cache {
    my ($sftp, $rfh, $len) = @_;

    $sftp->_clear_error_and_status;

    $sftp->flush($rfh, 'out')
	or return undef;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $bin = $rfh->_bin;

    if (defined $len) {
	return 1 if ($len < length $$bin);

	my $read_ahead = $sftp->{_read_ahead};
	$len = length($$bin) + $read_ahead
	    if $len - length($$bin) < $read_ahead;
    }

    my $pos = $rfh->_pos;

    my $qsize = $sftp->{_queue_size};
    my $bsize = $sftp->{_block_size};

    my @msgid;
    my $askoff = length $$bin;
    my $eof;

    while (!defined $len or length $$bin < $len) {
	while ((!defined $len or $askoff < $len) and @msgid < $qsize) {
	    my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
					  int64 => $pos + $askoff, int32 => $bsize);
	    push @msgid, $id;
	    $askoff += $bsize;
	}

	my $eid = shift @msgid;
	my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $eid,
					    SFTP_ERR_REMOTE_READ_FAILED,
					    "Couldn't read from remote file")
	    or last;

	my $data = $msg->get_str;
	$$bin .= $data;
	if (length $data < $bsize) {
	    unless (defined $len) {
		$eof = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
					     int64 => $pos + length $$bin, int32 => 1);
	    }
	    last;
	}

    }

    $sftp->_get_msg for @msgid;

    if ($eof) {
	$sftp->_get_msg_and_check(SSH2_FXP_DATA, $eof,
				  SFTP_ERR_REMOTE_BLOCK_TOO_SMALL,
				  "received block was too small")
    }

    if ($sftp->{_status} == SSH2_FX_EOF and length $$bin) {
	$sftp->_clear_error_and_status;
    }

    return $sftp->{_error} ? undef : length $$bin;
}

sub read {
    @_ == 3 or croak 'Usage: $sftp->read($fh, $len)';

    my ($sftp, $rfh, $len) = @_;
    if ($sftp->_fill_read_cache($rfh, $len)) {
	my $bin = $rfh->_bin;
	my $data = substr($$bin, 0, $len, '');
	$rfh->_inc_pos(length $data);
	return $data;
    }
    return undef;
}

sub _readline {
    my ($sftp, $rfh, $sep) = @_;

    $sep = "\n" if @_ < 3;

    my $sl = length $sep;

    my $bin = $rfh->_bin;
    my $last = 0;

    while(1) {
	my $ix = index $$bin, $sep, $last + 1 - $sl ;
	if ($ix >= 0) {
	    $ix += $sl;
	    $rfh->_inc_pos($ix);
	    return substr($$bin, 0, $ix, '');
	}

	$last = length $$bin;
	$sftp->_fill_read_cache($rfh, length($$bin) + 1);

	unless (length $$bin > $last) {
	    $sftp->{_error}
		and return undef;

	    my $line = $$bin;
	    $rfh->_inc_pos(length $line);
	    $$bin = '';
	    return $line;
	}
    }
}

sub readline {
    (@_ >= 2 and @_ <= 3)
	or croak 'Usage: $sftp->readline($fh [, $sep])';

    my ($sftp, $rfh, $sep) = @_;
    $sep = "\n" if @_ < 3;
    if (!defined $sep or $sep eq '') {
	$sftp->_fill_read_cache($rfh);
	$sftp->{_error}
	    and return undef;
	my $bin = $rfh->_bin;
	my $line = $$bin;
	$rfh->_inc_pos(length $line);
	$$bin = '';
	return $line;
    }
    if (wantarray) {
	my @lines;
	while (defined (my $line = $sftp->_readline($rfh, $sep))) {
	    push @lines, $line;
	}
	return @lines;
    }
    return $sftp->_readline($rfh, $sep);
}

sub getc {
    @_ == 2 or croak 'Usage: $sftp->getc($fh)';

    my ($sftp, $rfh) = @_;

    $sftp->_fill_read_cache($rfh, 1);
    my $bin = $rfh->_bin;
    if (length $bin) {
	$rfh->_inc_pos(1);
	return substr $$bin, 0, 1, '';
    }
    return undef;
}

sub _gen_stat_method {
    my ($code, $error, $errstr) = @_;
    return sub {
	@_ == 2 or croak 'Usage: $sftp->stat|lstat($path)';
        ${^TAINT} and &_catch_tainted_args;

	my ($sftp, $path) = @_;
        $path = $sftp->_rel2abs($path);
	my $id = $sftp->_queue_str_request($code, $sftp->_fs_encode($path));
	if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_ATTRS, $id,
						$error, $errstr)) {
	    return $msg->get_attributes;
	}
	return undef;
    };
}

## SSH2_FXP_LSTAT (7), SSH2_FXP_FSTAT (8), SSH2_FXP_STAT (17)
# these all return a Net::SFTP::Foreign::Attributes object on success, undef on failure

*lstat = _gen_stat_method(SSH2_FXP_LSTAT,
			  SFTP_ERR_REMOTE_LSTAT_FAILED,
			  "Couldn't stat remote file (lstat)");

*stat = _gen_stat_method(SSH2_FXP_STAT,
			 SFTP_ERR_REMOTE_FSTAT_FAILED,
			 "Couldn't stat remote file (stat)");

sub fstat {
    @_ == 2 or croak 'Usage: $sftp->fstat($fh)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my $id = $sftp->_queue_rfid_request(SSH2_FXP_FSTAT, @_);
    defined $id or return undef;
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_ATTRS, $id,
					    SFTP_ERR_REMOTE_STAT_FAILED,
					    "Couldn't stat remote file (fstat)")) {
	return $msg->get_attributes;
    }
    return undef;
}

## SSH2_FXP_RMDIR (15), SSH2_FXP_REMOVE (13)
# these return true on success, undef on failure

sub _gen_remove_method {
    my($code, $error, $errstr) = @_;
    return sub {
	@_ == 2 or croak 'Usage: $sftp->remove|rmdir($path)';
        ${^TAINT} and &_catch_tainted_args;

        my ($sftp, $path) = @_;
        $path = $sftp->_rel2abs($path);
        my $id = $sftp->_queue_str_request($code, $sftp->_fs_encode($path));
        return $sftp->_check_status_ok($id, $error, $errstr);
    };
}

*remove = _gen_remove_method(SSH2_FXP_REMOVE,
			     SFTP_ERR_REMOTE_REMOVE_FAILED,
			     "Couldn't delete remote file");

*rmdir = _gen_remove_method(SSH2_FXP_RMDIR,
			    SFTP_ERR_REMOTE_RMDIR_FAILED,
			    "Couldn't remove remote directory");


## SSH2_FXP_MKDIR (14), SSH2_FXP_SETSTAT (9)
# these return true on success, undef on failure

sub mkdir {
    (@_ >= 2 and @_ <= 3)
        or croak 'Usage: $sftp->mkdir($path [, $attrs])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $attrs) = @_;
    $attrs = _empty_attributes unless defined $attrs;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_MKDIR,
                                       $sftp->_fs_encode($path),
                                       $attrs);
    return $sftp->_check_status_ok($id,
                                   SFTP_ERR_REMOTE_MKDIR_FAILED,
                                   "Couldn't create remote directory");
}

sub join {
    my $sftp = shift;
    my $a = '.';
    while (@_) {
	my $b = shift;
	if (defined $b) {
	    $b =~ s|^(?:\./+)+||;
	    if (length $b and $b ne '.') {
		if ($b !~ m|^/| and $a ne '.' ) {
		    $a = ($a =~ m|/$| ? "$a$b" : "$a/$b");
		}
		else {
		    $a = $b
		}
		$a =~ s|(?:/+\.)+/?$|/|;
		$a =~ s|(?<=[^/])/+$||;
		$a = '.' unless length $a;
	    }
	}
    }
    $a;
}

sub _rel2abs {
    my ($sftp, $path) = @_;
    my $old = $path;
    my $cwd = $sftp->{cwd};
    $path = $sftp->join($sftp->{cwd}, $path);
    $debug and $debug & 4096 and _debug("'$old' --> '$path'");
    return $path
}

sub mkpath {
    (@_ >= 2 and @_ <= 3)
        or croak 'Usage: $sftp->mkpath($path [, $attrs])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $attrs) = @_;
    $sftp->_clear_error_and_status;

    $path =~ s{^(/*)}{};
    my $start = $1;
    my @path;
    while (1) {
	my $p = "$start$path";
	$debug and $debug & 8192 and _debug "checking $p";
	if ($sftp->test_d($p)) {
	    $debug and $debug & 8192 and _debug "$p is a dir";
	    last;
	}
	unless (length $path) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_MKDIR_FAILED,
                              "Unable to make path, bad root");
	    return undef;
	}
	unshift @path, $p;
	$path =~ s{/*[^/]*$}{};
    }
    for my $p (@path) {
	$debug and $debug & 8192 and _debug "mkdir $p";
	if ($p =~ m{^(?:.*/)?\.{1,2}$} or $p =~ m{/$}) {
	    $debug and $debug & 8192 and _debug "$p is a symbolic dir, skipping";
	    unless ($sftp->test_d($p)) {
		$debug and $debug & 8192 and _debug "symbolic dir $p can not be checked";
		$sftp->error or
		    $sftp->_set_error(SFTP_ERR_REMOTE_MKDIR_FAILED,
				      "Unable to make path, bad name");
		return undef;
	    }
	}
	else {
	    $sftp->mkdir($p, $attrs)
                or return undef;
	}
    }
    1;
}


sub setstat {
    @_ == 3 or croak 'Usage: $sftp->setstat($str, $attrs)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $attrs) = @_;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_SETSTAT,
                                       $sftp->_fs_encode($path),
                                       $attrs);
    return $sftp->_check_status_ok($id,
                                   SFTP_ERR_REMOTE_SETSTAT_FAILED,
                                   "Couldn't setstat remote file (setstat)'");
}

## SSH2_FXP_CLOSE (4), SSH2_FXP_FSETSTAT (10)
# these return true on success, undef on failure

sub fsetstat {
    @_ == 3 or croak 'Usage: $sftp->fsetstat($fh, $attrs)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my $id = $sftp->_queue_rid_request(SSH2_FXP_FSETSTAT, @_);
    defined $id or return undef;

    return $sftp->_check_status_ok($id,
                                   SFTP_ERR_REMOTE_FSETSTAT_FAILED,
                                   "Couldn't setstat remote file (fsetstat)");
}

sub _close {
    @_ == 2 or croak 'Usage: $sftp->close($fh, $attrs)';

    my $sftp = shift;
    my $id = $sftp->_queue_rid_request(SSH2_FXP_CLOSE, @_);
    defined $id or return undef;

    my $ok = $sftp->_check_status_ok($id,
                                     SFTP_ERR_REMOTE_CLOSE_FAILED,
                                     "Couldn't close remote file");

    if ($debug and $debug & 2) {
        _debug sprintf("closing file handle, return: %s, rid:", (defined $ok ? $ok : '-'));
        _hexdump($sftp->_rid($_[0]));
    }

    return $ok;
}

sub close {
    @_ == 2 or croak 'Usage: $sftp->close($fh)';

    my ($sftp, $rfh) = @_;
    $rfh->_check_is_file;
    $sftp->flush($rfh)
	or return undef;

    if ($sftp->_close($rfh)) {
	$rfh->_close;
	return 1
    }
    undef
}

sub closedir {
    @_ == 2 or croak 'Usage: $sftp->closedir($dh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $rdh) = @_;
    $rdh->_check_is_dir;

    if ($sftp->_close($rdh)) {
	$rdh->_close;
	return 1;
    }
    undef
}

sub readdir {
    @_ == 2 or croak 'Usage: $sftp->readdir($dh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $rdh) = @_;

    my $rdid = $sftp->_rdid($rdh);
    defined $rdid or return undef;

    my $cache = $rdh->_cache;

    while (!@$cache or wantarray) {
	my $id = $sftp->_queue_str_request(SSH2_FXP_READDIR, $rdid);
	if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
						SFTP_ERR_REMOTE_READDIR_FAILED,
						"Couldn't read remote directory" )) {
	    my $count = $msg->get_int32 or last;

	    for (1..$count) {
		push @$cache, { filename => $sftp->_fs_decode($msg->get_str),
				longname => $sftp->_fs_decode($msg->get_str),
				a => $msg->get_attributes };
	    }
	}
	else {
	    $sftp->_set_error if $sftp->status == SSH2_FX_EOF;
	    last;
	}
    }

    if (wantarray) {
	my $old = $cache;
	$cache = [];
	return @$old;
    }
    shift @$cache;
}

sub _readdir {
    my ($sftp, $rdh);
    if (wantarray) {
	my $line = $sftp->readdir($rdh);
	if (defined $line) {
	    return $line->{filename};
	}
    }
    else {
	return map { $_->{filename} } $sftp->readdir($rdh);
    }
}

sub _gen_getpath_method {
    my ($code, $error, $name) = @_;
    return sub {
	@_ == 2 or croak 'Usage: $sftp->some_method($path)';
        ${^TAINT} and &_catch_tainted_args;

	my ($sftp, $path) = @_;
	$path = $sftp->_rel2abs($path);
	my $id = $sftp->_queue_str_request($code, $sftp->_fs_encode($path));

	if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
						$error,
						"Couldn't get $name for remote '$path'")) {
	    $msg->get_int32 > 0
		and return $sftp->_fs_decode($msg->get_str);

	    $sftp->_set_error($error,
			      "Couldn't get $name for remote '$path', no names on reply")
	}
	return undef;
    };
}

## SSH2_FXP_REALPATH (16)
## SSH2_FXP_READLINK (19)
# return path on success, undef on failure
*realpath = _gen_getpath_method(SSH2_FXP_REALPATH,
				SFTP_ERR_REMOTE_REALPATH_FAILED,
				"realpath");
*readlink = _gen_getpath_method(SSH2_FXP_READLINK,
				SFTP_ERR_REMOTE_READLINK_FAILED,
				"link target");

## SSH2_FXP_RENAME (18)
# true on success, undef on failure

sub _rename {
    my ($sftp, $old, $new) = @_;

    $old = $sftp->_rel2abs($old);
    $new = $sftp->_rel2abs($new);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_RENAME,
                                   str => $sftp->_fs_encode($old),
                                   str => $sftp->_fs_encode($new));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_RENAME_FAILED,
                            "Couldn't rename remote file '$old' to '$new'");
}

sub rename {
    (@_ & 1) or croak 'Usage: $sftp->rename($old, $new, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $old, $new, %opts) = @_;

    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};
    croak "'overwrite' and 'numbered' options can not be used together"
        if ($overwrite and $numbered);
    %opts and _croak_bad_options(keys %opts);

    if ($overwrite) {
        $sftp->atomic_rename($old, $new) and return 1;
        $sftp->status != SSH2_FX_OP_UNSUPPORTED and return undef;
    }

    for (1) {
        local $sftp->{_autodie};
        # we are optimistic here and try to rename it without testing
        # if a file of the same name already exists first
        if (!$sftp->_rename($old, $new) and
            $sftp->status == SSH2_FX_FAILURE) {
            if ($numbered and $sftp->test_e($new)) {
                _inc_numbered($new);
                redo;
            }
            elsif ($overwrite) {
                my $rp_old = $sftp->realpath($old);
                my $rp_new = $sftp->realpath($new);
                if (defined $rp_old and defined $rp_new and $rp_old eq $rp_new) {
                    $sftp->_clear_error;
                }
                elsif ($sftp->remove($new)) {
                    $overwrite = 0;
                    redo;
                }
            }
        }
    }
    $sftp->_ok_or_autodie;
}

sub atomic_rename {
    @_ == 3 or croak 'Usage: $sftp->atomic_rename($old, $new)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $old, $new) = @_;

    $sftp->_check_extension('posix-rename@openssh.com' => 1,
                             SFTP_ERR_REMOTE_RENAME_FAILED,
                            "atomic rename failed")
        or return undef;

    $old = $sftp->_rel2abs($old);
    $new = $sftp->_rel2abs($new);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'posix-rename@openssh.com',
                                   str => $sftp->_fs_encode($old),
                                   str => $sftp->_fs_encode($new));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_RENAME_FAILED,
                            "Couldn't rename remote file '$old' to '$new'");
}

## SSH2_FXP_SYMLINK (20)
# true on success, undef on failure
sub symlink {
    @_ == 3 or croak 'Usage: $sftp->symlink($sl, $target)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $sl, $target) = @_;
    $sl = $sftp->_rel2abs($sl);
    my $id = $sftp->_queue_new_msg(SSH2_FXP_SYMLINK,
                                   str => $sftp->_fs_encode($target),
                                   str => $sftp->_fs_encode($sl));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_SYMLINK_FAILED,
                            "Couldn't create symlink '$sl' pointing to '$target'");
}

sub hardlink {
    @_ == 3 or croak 'Usage: $sftp->hardlink($hl, $target)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $hl, $target) = @_;

    $sftp->_check_extension('hardlink@openssh.com' => 1,
                            SFTP_ERR_REMOTE_HARDLINK_FAILED,
                            "hardlink failed")
        or return undef;
    $hl = $sftp->_rel2abs($hl);
    $target = $sftp->_rel2abs($target);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'hardlink@openssh.com',
                                   str => $sftp->_fs_encode($target),
                                   str => $sftp->_fs_encode($hl));
    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_HARDLINK_FAILED,
                            "Couldn't create hardlink '$hl' pointing to '$target'");
}

sub _gen_save_status_method {
    my $method = shift;
    sub {
	my $sftp = shift;
        local ($sftp->{_error}, $sftp->{_status}) if $sftp->{_error};
	$sftp->$method(@_);
    }
}

*_close_save_status = _gen_save_status_method('close');
*_closedir_save_status = _gen_save_status_method('closedir');
*_remove_save_status = _gen_save_status_method('remove');

sub _inc_numbered {
    $_[0] =~ s{^(.*)\((\d+)\)((?:\.[^\.]*)?)$}{"$1(" . ($2+1) . ")$3"}e or
    $_[0] =~ s{((?:\.[^\.]*)?)$}{(1)$1};
    $debug and $debug & 128 and _debug("numbering to: $_[0]");
}

## High-level client -> server methods.

sub abort {
    my $sftp = shift;
    $sftp->_set_error(SFTP_ERR_ABORTED, ($@ ? $_[0] : "Aborted"));
}

# returns true on success, undef on failure
sub get {
    @_ >= 2 or croak 'Usage: $sftp->get($remote, $local, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $remote, $local, %opts) = @_;
    defined $remote or croak "remote file path is undefined";

    $sftp->_clear_error_and_status;

    $remote = $sftp->_rel2abs($remote);
    $local = _file_part($remote) unless defined $local;
    my $local_is_fh = (ref $local and $local->isa('GLOB'));

    my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $perm = delete $opts{perm};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};
    my $overwrite = delete $opts{overwrite};
    my $resume = delete $opts{resume};
    my $append = delete $opts{append};
    my $block_size = delete $opts{block_size} || $sftp->{_block_size};
    my $queue_size = delete $opts{queue_size} || $sftp->{_queue_size};
    my $dont_save = delete $opts{dont_save};
    my $conversion = delete $opts{conversion};
    my $numbered = delete $opts{numbered};
    my $cleanup = delete $opts{cleanup};
    my $atomic = delete $opts{atomic};

    croak "'perm' and 'umask' options can not be used simultaneously"
	if (defined $perm and defined $umask);
    croak "'perm' and 'copy_perm' options can not be used simultaneously"
	if (defined $perm and defined $copy_perm);
    croak "'resume' and 'append' options can not be used simultaneously"
	if ($resume and $append);
    croak "'numbered' can not be used with 'overwrite', 'resume' or 'append'"
	if ($numbered and ($overwrite or $resume or $append));
    croak "'atomic' can not be used with 'resume' or 'append'"
        if ($atomic and ($resume or $append));
    if ($local_is_fh) {
	my $append = 'option can not be used when target is a file handle';
	$resume and croak "'resume' $append";
	$overwrite and croak "'overwrite' $append";
	$numbered and croak "'numbered' $append";
	$dont_save and croak "'dont_save' $append";
        $atomic and croak "'croak' $append";
    }
    %opts and _croak_bad_options(keys %opts);

    if ($resume and $conversion) {
        carp "resume option is useless when data conversion has also been requested";
        undef $resume;
    }

    my $oldumask = umask;
    my $neg_umask;

    if (defined $perm) {
	$neg_umask = $perm;
    }
    else {
	$umask = $oldumask unless defined $umask;
	$neg_umask = 0777 & ~$umask;
    }

    $overwrite = 1 unless (defined $overwrite or $local_is_fh or $numbered);
    $copy_perm = 1 unless (defined $perm or defined $copy_perm or $local_is_fh);
    $copy_time = 1 unless (defined $copy_time or $local_is_fh);
    $cleanup = ($atomic || $numbered) unless defined $cleanup;

    my $a = do {
        local $sftp->{_autodie};
        $sftp->stat($remote);
    };
    my ($rperm, $size, $atime, $mtime) = ($a ? ($a->perm, $a->size, $a->atime, $a->mtime) : ());
    $size = -1 unless defined $size;

    if ($copy_time and not defined $atime) {
        $sftp->_ok_or_autodie and $sftp->_set_error(SFTP_ERR_REMOTE_STAT_FAILED,
                                                    "Not enough information on stat, amtime not included");
        return undef;
    }

    if ($copy_perm) {
        if (defined $rperm) {
            $perm = $rperm;
        }
        else {
            $sftp->_ok_or_autodie and $sftp->_set_error(SFTP_ERR_REMOTE_STAT_FAILED,
                                                        "Not enough information on stat, mode not included");
            return undef
        }
    }
    $sftp->_clear_error_and_status;

    if ($resume and $resume eq 'auto') {
        undef $resume;
        if (defined $mtime) {
            if (my @lstat = CORE::stat $local) {
                $resume = ($mtime <= $lstat[9]);
            }
        }
    }

    my ($atomic_numbered, $atomic_local, $atomic_cleanup);

    my ($rfh, $fh);
    my $askoff = 0;
    my $lstart = 0;

    if ($dont_save) {
        $rfh = $sftp->open($remote, SSH2_FXF_READ);
        defined $rfh or return undef;
    }
    else {
        unless ($local_is_fh or $overwrite or $append or $resume or $numbered) {
	    if (-e $local) {
                $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
                                  "local file $local already exists");
                return undef
	    }
        }

        if ($atomic) {
            $atomic_local = $local;
            $local .= sprintf("(%d).tmp", rand(10000));
            $atomic_numbered = $numbered;
            $numbered = 1;
            $debug and $debug & 128 and _debug("temporal local file name: $local");
        }

        $perm = (0666 & $neg_umask) unless defined $perm or $local_is_fh;

        if ($resume) {
            if (CORE::open $fh, '+<', $local) {
                binmode $fh;
		CORE::seek($fh, 0, 2);
                $askoff = CORE::tell $fh;
                if ($askoff < 0) {
                    # something is going really wrong here, fall
                    # back to non-resuming mode...
                    $askoff = 0;
                    undef $fh;
                }
                else {
                    if ($size >=0 and $askoff > $size) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_BIGGER_THAN_REMOTE,
                                          "Couldn't resume transfer, local file is bigger than remote");
                        return undef;
                    }
                    $size == $askoff and return 1;
                }
            }
        }

        # we open the remote file so late in order to skip it when
        # resuming an already completed transfer:
        $rfh = $sftp->open($remote, SSH2_FXF_READ);
        defined $rfh or return undef;

	unless (defined $fh) {
	    if ($local_is_fh) {
		$fh = $local;
		local ($@, $SIG{__DIE__}, $SIG{__WARN__});
		eval { $lstart = CORE::tell($fh) };
		$lstart = 0 unless ($lstart and $lstart > 0);
	    }
	    else {
                my $flags = Fcntl::O_CREAT|Fcntl::O_WRONLY;
                $flags |= Fcntl::O_APPEND if $append;
                $flags |= Fcntl::O_EXCL if ($numbered or (!$overwrite and !$append));

                my $lumask = ~$perm & 0777;

                unlink $local if ($overwrite and !$numbered);

                while (1) {
                    umask $lumask;
                    sysopen ($fh, $local, $flags, $perm) and last;
                    my $err = $!;
                    umask $oldumask;
                    unless ($numbered and -e $local) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
                                          "Can't open $local", $err);
                        return undef;
                    }
                    _inc_numbered($local);
                }
                umask $oldumask;
                $$numbered = $local if ref $numbered;
		binmode $fh;
		$lstart = sysseek($fh, 0, 1) if $append;
	    }
	}

	if (defined $perm) {
	    local ($@, $SIG{__DIE__}, $SIG{__WARN__});
	    my $e = eval { chmod($perm & $neg_umask, $local) };
	    if ($@ or $e <= 0) {
                my $err = $!;
                unlink $local;
		$sftp->_set_error(SFTP_ERR_LOCAL_CHMOD_FAILED,
				  "Can't chmod $local", ($@ ? $@ : $err));
		return undef
	    }
	}
    }

    my $converter = _gen_converter $conversion;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or die "internal error: rfid not defined";

    my @msgid;
    my @askoff;
    my $loff = $askoff;
    my $adjustment = 0;
    my $n = 0;
    local $\;
    do {
        # Disable autodie here in order to do not leave unhandled
        # responses queued on the connection in case of failure.
        local $sftp->{_autodie};

        # Again, once this point is reached, all code paths should end
        # through the CLEANUP block.

        while (1) {
            # request a new block if queue is not full
            while (!@msgid or (($size == -1 or $size > $askoff) and @msgid < $queue_size and $n != 1)) {

                my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
                                               int64 => $askoff, int32 => $block_size);
                push @msgid, $id;
                push @askoff, $askoff;
                $askoff += $block_size;
                $n++;
            }

            my $eid = shift @msgid;
            my $roff = shift @askoff;

            my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $eid,
                                                SFTP_ERR_REMOTE_READ_FAILED,
                                                "Couldn't read from remote file");

            unless ($msg) {
                if ($sftp->{_status} == SSH2_FX_EOF) {
                    $sftp->_set_error();
                    $roff != $loff and next;
                }
                last;
            }

            my $data = $msg->get_str;
            my $len = length $data;

            if ($roff != $loff or !$len) {
                $sftp->_set_error(SFTP_ERR_REMOTE_BLOCK_TOO_SMALL,
                                  "remote packet received is too small" );
                last;
            }

            $loff += $len;
            if ($len < $block_size) {
                $block_size = $len < 2048 ? 2048 : $len;
                $askoff = $loff;
            }

            my $adjustment_before = $adjustment;
            $adjustment += $converter->($data) if $converter;

            if (length($data) and defined $cb) {
                # $size = $loff if ($loff > $size and $size != -1);
                $cb->($sftp, $data,
                      $lstart + $roff + $adjustment_before,
                      $lstart + $size + $adjustment);

                last if $sftp->error;
            }

            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    last;
                }
            }
        }

        $sftp->_get_msg for (@msgid);

        goto CLEANUP if $sftp->{_error};

        # if a converter is in place, and aditional call has to be
        # performed in order to flush any pending buffered data
        if ($converter) {
            my $data = '';
            my $adjustment_before = $adjustment;
            $adjustment += $converter->($data);

            if (length($data) and defined $cb) {
                # $size = $loff if ($loff > $size and $size != -1);
                $cb->($sftp, $data, $askoff + $adjustment_before, $size + $adjustment);
                goto CLEANUP if $sftp->{_error};
            }

            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    goto CLEANUP;
                }
            }
        }

        # we call the callback one last time with an empty string;
        if (defined $cb) {
            my $data = '';
            $cb->($sftp, $data, $askoff + $adjustment, $size + $adjustment);
            return undef if $sftp->error;
            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    goto CLEANUP;
                }
            }
        }

        unless ($dont_save) {
            unless ($local_is_fh or CORE::close $fh) {
                $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                  "unable to write data to local file $local", $!);
                goto CLEANUP;
            }

            # we can be running on taint mode, so some checks are
            # performed to untaint data from the remote side.

            if ($copy_time and not utime($atime, $mtime, $local)) {
                $sftp->_set_error(SFTP_ERR_LOCAL_UTIME_FAILED,
                                  "Can't utime $local", $!);
                goto CLEANUP;
            }
        }

        if ($atomic) {
            if (!$overwrite) {
                while (1) {
                    # performing a non-overwriting atomic rename is
                    # quite burdensome: first, link is tried, if that
                    # fails, non-overwriting is favoured over
                    # atomicity and an empty file is used to lock the
                    # path before atempting an overwriting rename.
                    if (link $local, $atomic_local) {
                        unlink $local;
                        last;
                    }
                    my $err = $!;
                    unless (-e $atomic_local) {
                        if (sysopen my $lock, $atomic_local,
                            Fcntl::O_CREAT|Fcntl::O_EXCL|Fcntl::O_WRONLY,
                            0600) {
                            $atomic_cleanup = 1;
                            goto OVERWRITE;
                        }
                        $err = $!;
                        unless (-e $atomic_local) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
                                              "Can't open $local", $err);
                            goto CLEANUP;
                        }
                    }
                    unless ($numbered) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
                                          "local file $atomic_local already exists");
                        goto CLEANUP;
                    }
                    _inc_numbered($atomic_local);
                }
            }
            else {
            OVERWRITE:
                unless (CORE::rename $local, $atomic_local) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_RENAME_FAILED,
                                      "Unable to rename temporal file to its final position '$atomic_local'", $!);

                    goto CLEANUP;
                }
            }
            $$atomic_numbered = $local if ref $atomic_numbered;
        }

    CLEANUP:
        if ($cleanup and $sftp->{_error}) {
            unlink $local;
            unlink $atomic_local if $atomic_cleanup;
        }

    }; # autodie flag is restored here!

    $sftp->_ok_or_autodie;
}

# return file contents on success, undef on failure
sub get_content {
    @_ == 2 or croak 'Usage: $sftp->get_content($remote)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $name) = @_;
    $name = $sftp->_rel2abs($name);
    my @data;

    my $rfh = $sftp->open($name)
	or return undef;

    scalar $sftp->readline($rfh, undef);
}

sub put {
    @_ >= 2 or croak 'Usage: $sftp->put($local, $remote, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $local, $remote, %opts) = @_;
    defined $local or croak "local file path is undefined";

    $sftp->_clear_error_and_status;

    my $local_is_fh = (ref $local and $local->isa('GLOB'));
    unless (defined $remote) {
        $local_is_fh and croak "unable to infer remote file name when a file handler is passed as local";
        $remote = (File::Spec->splitpath($local))[2];
    }
    $remote = $sftp->_rel2abs($remote);

    my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $perm = delete $opts{perm};
    my $copy_perm = delete $opts{copy_perm};
    $copy_perm = delete $opts{copy_perms} unless defined $copy_perm;
    my $copy_time = delete $opts{copy_time};
    my $overwrite = delete $opts{overwrite};
    my $resume = delete $opts{resume};
    my $append = delete $opts{append};
    my $block_size = delete $opts{block_size} || $sftp->{_block_size};
    my $queue_size = delete $opts{queue_size} || $sftp->{_queue_size};
    my $conversion = delete $opts{conversion};
    my $late_set_perm = delete $opts{late_set_perm};
    my $numbered = delete $opts{numbered};
    my $atomic = delete $opts{atomic};
    my $cleanup = delete $opts{cleanup};

    croak "'perm' and 'umask' options can not be used simultaneously"
	if (defined $perm and defined $umask);
    croak "'perm' and 'copy_perm' options can not be used simultaneously"
	if (defined $perm and $copy_perm);
    croak "'resume' and 'append' options can not be used simultaneously"
	if ($resume and $append);
    croak "'resume' and 'overwrite' options can not be used simultaneously"
	if ($resume and $overwrite);
    croak "'numbered' can not be used with 'overwrite', 'resume' or 'append'"
	if ($numbered and ($overwrite or $resume or $append));
    croak "'atomic' can not be used with 'resume' or 'append'"
        if ($atomic and ($resume or $append));

    %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);
    $copy_perm = 1 unless (defined $perm or defined $copy_perm or $local_is_fh);
    $copy_time = 1 unless (defined $copy_time or $local_is_fh);
    $late_set_perm = $sftp->{_late_set_perm} unless defined $late_set_perm;
    $cleanup = ($atomic || $numbered) unless defined $cleanup;

    my $neg_umask;
    if (defined $perm) {
	$neg_umask = $perm;
    }
    else {
	$umask = umask unless defined $umask;
	$neg_umask = 0777 & ~$umask;
    }

    my ($fh, $lmode, $lsize, $latime, $lmtime);
    if ($local_is_fh) {
	$fh = $local;
	# we don't set binmode for the passed file handle on purpose
    }
    else {
	unless (CORE::open $fh, '<', $local) {
	    $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
			      "Unable to open local file '$local'", $!);
	    return undef;
	}
	binmode $fh;
    }

    {
	# as $fh can come from the outside, it may be a tied object
	# lacking support for some methods, so we call them wrapped
	# inside eval blocks
	local ($@, $SIG{__DIE__}, $SIG{__WARN__});
	if ((undef, undef, $lmode, undef, undef,
	     undef, undef, $lsize, $latime, $lmtime) =
	    eval {
		no warnings; # Calling stat on a tied handler
                             # generates a warning because the op is
                             # not supported by the tie API.
		CORE::stat $fh;
	    }
	   ) {
	    # $fh can point at some place inside the file, not just at the
	    # begining
	    if ($local_is_fh and defined $lsize) {
		my $tell = eval { CORE::tell $fh };
		$lsize -= $tell if ($tell and $tell > 0);
	    }
	}
	elsif ($copy_perm or $copy_time) {
	    $sftp->_set_error(SFTP_ERR_LOCAL_STAT_FAILED,
			      "Couldn't stat local file '$local'", $!);
	    return undef;
	}
	elsif ($resume and $resume eq 'auto') {
            $debug and $debug & 16384 and _debug "not resuming because stat'ing the local file failed";
	    undef $resume
	}
    }

    $perm = $lmode & $neg_umask if $copy_perm;
    my $attrs = Net::SFTP::Foreign::Attributes->new;
    $attrs->set_perm($perm) if defined $perm;

    my $rfh;
    my $writeoff = 0;
    my $converter = _gen_converter $conversion;
    my $converted_input = '';

    if ($resume or $append) {
	my $rattrs = $sftp->stat($remote);
	if ($rattrs) {
	    if ($resume and $resume eq 'auto' and $rattrs->mtime >= $lmtime) {
                $debug and $debug & 16384 and
                    _debug "not resuming because local file is newer, r: ".$rattrs->mtime." l: $lmtime";
		undef $resume;
	    }
	    else {
		$writeoff = $rattrs->size;
		$debug and $debug & 16384 and _debug "resuming from $writeoff";
	    }
	}
	elsif ($append) {
	    return undef unless $sftp->status == SSH2_FX_NO_SUCH_FILE;
	    undef $append;
	}

	if ($resume and $writeoff) {
            $debug and $debug & 16384 and _debug "resuming file transfer from $writeoff";
            if ($converter) {
                # as size could change, we have to read and convert
                # data until we reach the given position on the local
                # file:
                my $off = 0;
                my $eof_t;
                while (1) {
                    my $len = length $converted_input;
                    my $delta = $writeoff - $off;
                    if ($delta <= $len) {
                        $debug and $debug & 16384 and _debug "discarding $delta converted bytes";
                        substr $converted_input, 0, $delta, '';
                        last;
                    }
                    else {
                        $off += $len;
                        if ($eof_t) {
                            $sftp->_set_error(SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
                                              "Couldn't resume transfer, remote file is bigger than local");
                            return undef;
                        }
                        my $read = CORE::read($fh, $converted_input, $block_size * 4);
                        unless (defined $read) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                              "Couldn't read from local file '$local' to the resume point $writeoff", $!);
                            return undef;
                        }
                        $lsize += $converter->($converted_input) if defined $lsize;
                        utf8::downgrade($converted_input, 1)
				or croak "converter introduced wide characters in data";
                        $read or $eof_t = 1;
                    }
                }
            }
	    elsif ($local_is_fh) {
		# as some PerlIO layer could be installed on the $fh,
		# just seeking to the resume position will not be
		# enough. We have to read and discard data until the
		# desired offset is reached
		my $off = $writeoff;
		while ($off) {
		    my $read = CORE::read($fh, my($buf), ($off < 16384 ? $off : 16384));
		    if ($read) {
                        $debug and $debug & 16384 and _debug "discarding $read bytes";
			$off -= $read;
		    }
		    else {
			$sftp->_set_error(defined $read
					  ? ( SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
					      "Couldn't resume transfer, remote file is bigger than local")
					  : ( SFTP_ERR_LOCAL_READ_ERROR,
					      "Couldn't read from local file handler '$local' to the resume point $writeoff", $!));
		    }
		}
	    }
            else {
                if (defined $lsize and $writeoff > $lsize) {
                    $sftp->_set_error(SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
                                      "Couldn't resume transfer, remote file is bigger than local");
                    return undef;
                }
                unless (CORE::seek($fh, $writeoff, 0)) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_SEEK_FAILED,
                                      "seek operation on local file failed: $!");
                    return undef;
                }
            }
            if (defined $lsize and $writeoff == $lsize) {
                if (defined $perm and $rattrs->perm != $perm) {
                    return $sftp->setstat($remote, $attrs);
                }
                return 1;
            }
            $rfh = $sftp->open($remote, SSH2_FXF_WRITE)
                or return undef;
        }
    }

    my ($atomic_numbered, $atomic_remote);

    unless (defined $rfh) {
        if ($atomic) {
            # check that does not exist a file of the same name that
            # would block the rename operation at the end
            if (!($numbered or $overwrite) and
                $sftp->test_e($remote)) {
                $sftp->_set_status(SSH2_FX_FAILURE);
                $sftp->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
                                  "Remote file '$remote' already exists");
                return undef;
            }
            $atomic_remote = $remote;
            $remote .= sprintf("(%d).tmp", rand(10000));
            $atomic_numbered = $numbered;
            $numbered = 1;
            $debug and $debug & 128 and _debug("temporal remote file name: $remote");
        }
	if ($numbered) {
            while (1) {
                local $sftp->{_autodie};
                $rfh = $sftp->open($remote,
                                   SSH2_FXF_WRITE | SSH2_FXF_CREAT | SSH2_FXF_EXCL,
                                   $attrs);
                last if ($rfh or
                         $sftp->status != SSH2_FX_FAILURE or
                         !$sftp->test_e($remote));
                _inc_numbered($remote);
	    }
            $sftp->_ok_or_autodie;
            $$numbered = $remote if ref $numbered;
	}
        else {
            $rfh = $sftp->open($remote,
                               SSH2_FXF_WRITE | SSH2_FXF_CREAT |
                               ($append ? 0 : ($overwrite ? SSH2_FXF_TRUNC : SSH2_FXF_EXCL)),
                               $attrs)
                or return undef;
        }
    }

    $sftp->_ok_or_autodie or return undef;
    # Once this point is reached and for the remaining of the sub,
    # code should never return but jump into the CLEANUP block.

    do {
        local $sftp->{autodie};

        # In some SFTP server implementations, open does not set the
        # attributes for existent files so we do it again. The
        # $late_set_perm work around is for some servers that do not
        # support changing the permissions of open files
        if (defined $perm and !$late_set_perm) {
            $sftp->fsetstat($rfh, $attrs) or goto CLEANUP;
        }

        my $rfid = $sftp->_rfid($rfh);
        defined $rfid or die "internal error: rfid is undef";

        # In append mode we add the size of the remote file in
        # writeoff, if lsize is undef, we initialize it to $writeoff:
        $lsize += $writeoff if ($append or not defined $lsize);

        # when a converter is used, the EOF can become delayed by the
        # buffering introduced, we use $eof_t to account for that.
        my ($eof, $eof_t);
        my @msgid;
    OK: while (1) {
            if (!$eof and @msgid < $queue_size) {
                my ($data, $len);
                if ($converter) {
                    while (!$eof_t and length $converted_input < $block_size) {
                        my $read = CORE::read($fh, my $input, $block_size * 4);
                        unless ($read) {
                            unless (defined $read) {
                                $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                                  "Couldn't read from local file '$local'", $!);
                                last OK;
                            }
                            $eof_t = 1;
                        }

                        # note that the $converter is called a last time
                        # with an empty string
                        $lsize += $converter->($input);
                        utf8::downgrade($input, 1)
                                or croak "converter introduced wide characters in data";
                        $converted_input .= $input;
                    }
                    $data = substr($converted_input, 0, $block_size, '');
                    $len = length $data;
                    $eof = 1 if ($eof_t and !$len);
                }
                else {
                    $debug and $debug & 16384 and
                        _debug "reading block at offset ".CORE::tell($fh)." block_size: $block_size";

                    $len = CORE::read($fh, $data, $block_size);

                    if ($len) {
                        $debug and $debug & 16384 and _debug "block read, size: $len";

                        utf8::downgrade($data, 1)
                                or croak "wide characters unexpectedly read from file";

                        $debug and $debug & 16384 and length $data != $len and
                            _debug "read data changed size on downgrade to " . length($data);
                    }
                    else {
                        unless (defined $len) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                              "Couldn't read from local file '$local'", $!);
                            last OK;
                        }
                        $eof = 1;
                    }
                }

                my $nextoff = $writeoff + $len;

                if (defined $cb) {
                    $lsize = $nextoff if $nextoff > $lsize;
                    $cb->($sftp, $data, $writeoff, $lsize);

                    last OK if $sftp->error;

                    utf8::downgrade($data, 1) or croak "callback introduced wide characters in data";

                    $len = length $data;
                    $nextoff = $writeoff + $len;
                }

                if ($len) {
                    $debug and $debug & 16384 and
                        _debug "writing block at offset $writeoff, length " . length($data);

                    my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
                                                   int64 => $writeoff, str => $data);
                    push @msgid, $id;
                    $writeoff = $nextoff;
                }
            }

            last if ($eof and !@msgid);

            next unless  ($eof
                          or @msgid >= $queue_size
                          or $sftp->_do_io(0));

            my $id = shift @msgid;
            unless ($sftp->_check_status_ok($id,
                                            SFTP_ERR_REMOTE_WRITE_FAILED,
                                            "Couldn't write to remote file")) {
                last OK;
            }
        }

        CORE::close $fh unless $local_is_fh;

        $sftp->_get_msg for (@msgid);

        $sftp->_close_save_status($rfh);

        goto CLEANUP if $sftp->{_error};

        # for servers that does not support setting permissions on open files
        if (defined $perm and $late_set_perm) {
            $sftp->setstat($remote, $attrs);
        }

        if ($copy_time) {
            $attrs = Net::SFTP::Foreign::Attributes->new;
            $attrs->set_amtime($latime, $lmtime);
            $sftp->setstat($remote, $attrs) or goto CLEANUP;
        }

        if ($atomic) {
            $sftp->rename($remote, $atomic_remote,
                          overwrite => $overwrite,
                          numbered => $atomic_numbered) or goto CLEANUP;
        }

    CLEANUP:
        if ($cleanup and $sftp->{_error}) {
            warn "cleanup $remote";
            $sftp->_remove_save_status($remote);
        }
    };
    $sftp->_ok_or_autodie;
}

sub ls {
    @_ >= 1 or croak 'Usage: $sftp->ls($remote_dir, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my %opts = @_ & 1 ? (dir => @_) : @_;

    my $dir = delete $opts{dir};
    my $ordered = delete $opts{ordered};
    my $follow_links = delete $opts{follow_links};
    my $atomic_readdir = delete $opts{atomic_readdir};
    my $names_only = delete $opts{names_only};
    my $realpath = delete $opts{realpath};
    my $queue_size = delete $opts{queue_size};
    my $cheap = ($names_only and !$realpath); 
    my ($cheap_wanted, $wanted);
    if ($cheap and
	ref $opts{wanted} eq 'RegExp' and 
	not defined $opts{no_wanted}) {
	$cheap_wanted = delete $opts{wanted}
    }
    else {
	$wanted = (delete $opts{_wanted} ||
		   _gen_wanted(delete $opts{wanted},
			       delete $opts{no_wanted}));
	undef $cheap if defined $wanted;
    }

    %opts and _croak_bad_options(keys %opts);

    my $delayed_wanted = ($atomic_readdir and $wanted);
    $queue_size = 1 if ($follow_links or $realpath or
			($wanted and not $delayed_wanted));
    my $max_queue_size = $queue_size || $sftp->{_queue_size};
    $queue_size ||= 2;

    $dir = '.' unless defined $dir;
    $dir = $sftp->_rel2abs($dir);

    my $rdh = $sftp->opendir($dir);
    return unless defined $rdh;

    my $rdid = $sftp->_rdid($rdh);
    defined $rdid or return undef;

    my @dir;
    my @msgid;

    do {
        local $sftp->{_autodie};
    OK: while (1) {
            push @msgid, $sftp->_queue_str_request(SSH2_FXP_READDIR, $rdid)
                while (@msgid < $queue_size);

            my $id = shift @msgid;
            if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
                                                    SFTP_ERR_REMOTE_READDIR_FAILED,
                                                    "Couldn't read directory '$dir'" )) {
                my $count = $msg->get_int32 or last;

                if ($cheap) {
                    for (1..$count) {
                        my $fn = $sftp->_fs_decode($msg->get_str);
                        push @dir, $fn if (!defined $cheap_wanted or $fn =~ $cheap_wanted);
                        $msg->skip_str;
                        Net::SFTP::Foreign::Attributes->skip_from_buffer($msg);
                    }
                }
                else {
                    for (1..$count) {
                        my $fn = $sftp->_fs_decode($msg->get_str);
                        my $ln = $sftp->_fs_decode($msg->get_str);
                        # my $a = $msg->get_attributes;
                        my $a = Net::SFTP::Foreign::Attributes->new_from_buffer($msg);

                        my $entry =  { filename => $fn,
                                       longname => $ln,
                                       a => $a };

                        if ($follow_links and _is_lnk($a->perm)) {

                            if ($a = $sftp->stat($sftp->join($dir, $fn))) {
                                $entry->{a} = $a;
                            }
                            else {
                                $sftp->_clear_error_and_status;
                            }
                        }

                        if ($realpath) {
                            my $rp = $sftp->realpath($sftp->join($dir, $fn));
                            if (defined $rp) {
                                $fn = $entry->{realpath} = $rp;
                            }
                            else {
                                $sftp->_clear_error_and_status;
                            }
                        }

                        if (!$wanted or $delayed_wanted or $wanted->($sftp, $entry)) {
                            push @dir, (($names_only and !$delayed_wanted) ? $fn : $entry);
                        }
                    }
                }

                $queue_size ++ if $queue_size < $max_queue_size;
            }
            else {
                $sftp->_set_error if $sftp->{_status} == SSH2_FX_EOF;
                $sftp->_get_msg for @msgid;
                last;
            }
        }
        $sftp->_closedir_save_status($rdh) if $rdh;
    };
    unless ($sftp->error) {
	if ($delayed_wanted) {
	    @dir = grep { $wanted->($sftp, $_) } @dir;
	    @dir = map { defined $_->{realpath}
			 ? $_->{realpath}
			 : $_->{filename} } @dir
		if $names_only;
	}
        if ($ordered) {
            if ($names_only) {
                @dir = sort @dir;
            }
            else {
                _sort_entries \@dir;
            }
        }
	return \@dir;
    }
    croak $sftp->error if $sftp->{_autodie};
    return undef;
}

sub rremove {
    @_ >= 2 or croak 'Usage: $sftp->rremove($dirs, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $dirs, %opts) = @_;

    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted});

    %opts and _croak_bad_options(keys %opts);

    my $count = 0;

    my @dirs;
    $sftp->find( $dirs,
		 on_error => $on_error,
		 atomic_readdir => 1,
		 wanted => sub {
		     my $e = $_[1];
		     my $fn = $e->{filename};
		     if (_is_dir($e->{a}->perm)) {
			 push @dirs, $e;
		     }
		     else {
			 if (!$wanted or $wanted->($sftp, $e)) {
			     if ($sftp->remove($fn)) {
				 $count++;
			     }
			     else {
				 $sftp->_call_on_error($on_error, $e);
			     }
			 }
		     }
		 } );

    _sort_entries(\@dirs);

    while (@dirs) {
	my $e = pop @dirs;
	if (!$wanted or $wanted->($sftp, $e)) {
	    if ($sftp->rmdir($e->{filename})) {
		$count++;
	    }
	    else {
		$sftp->_call_on_error($on_error, $e);
	    }
	}
    }

    return $count;
}

sub get_symlink {
    @_ >= 3 or croak 'Usage: $sftp->get_symlink($remote, $local, %opts)';
    my ($sftp, $remote, $local, %opts) = @_;
    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};

    croak "'overwrite' and 'numbered' can not be used together"
	if ($overwrite and $numbered);
   %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);

    my $a = $sftp->lstat($remote) or return undef;
    unless (_is_lnk($a->perm)) {
	$sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			  "Remote object '$remote' is not a symlink");
	return undef;
    }

    my $link = $sftp->readlink($remote) or return undef;

    # TODO: this is too weak, may contain race conditions.
    if ($numbered) {
        _inc_numbered($local) while -e $local;
    }
    elsif (-e $local) {
	if ($overwrite) {
	    unlink $local;
	}
	else {
	    $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
			      "local file $local already exists");
	    return undef
	}
    }

    unless (eval { CORE::symlink $link, $local }) {
	$sftp->_set_error(SFTP_ERR_LOCAL_SYMLINK_FAILED,
			  "creation of symlink '$local' failed", $!);
	return undef;
    }
    $$numbered = $local if ref $numbered;

    1;
}

sub put_symlink {
    @_ >= 3 or croak 'Usage: $sftp->put_symlink($local, $remote, %opts)';
    my ($sftp, $local, $remote, %opts) = @_;
    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};

    croak "'overwrite' and 'numbered' can not be used together"
	if ($overwrite and $numbered);
    %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);
    my $perm = (lstat $local)[2];
    unless (defined $perm) {
	$sftp->_set_error(SFTP_ERR_LOCAL_STAT_FAILED,
			  "Couldn't stat local file '$local'", $!);
	return undef;
    }
    unless (_is_lnk($perm)) {
	$sftp->_set_error(SFTP_ERR_LOCAL_BAD_OBJECT,
			  "Local file $local is not a symlink");
	return undef;
    }
    my $target = readlink $local;
    unless (defined $target) {
	$sftp->_set_error(SFTP_ERR_LOCAL_READLINK_FAILED,
			  "Couldn't read link '$local'", $!);
	return undef;
    }

    while (1) {
        local $sftp->{_autodie};
        $sftp->symlink($remote, $target);
        if ($sftp->error and
            $sftp->status == SSH2_FX_FAILURE) {
            if ($numbered and $sftp->test_e($remote)) {
                _inc_numbered($remote);
                redo;
            }
            elsif ($overwrite and $sftp->_remove_save_status($remote)) {
                $overwrite = 0;
                redo;
            }
        }
        last
    }
    $$numbered = $remote if ref $numbered;
    $sftp->_ok_or_autodie;
}

sub rget {
    @_ >= 2 or croak 'Usage: $sftp->rget($remote, $local, %opts)';
    ${^TAINT} and &_catch_tainted_args;
    my ($sftp, $remote, $local, %opts) = @_;

    defined $remote or croak "remote file path is undefined";
    $local = File::Spec->curdir unless defined $local;

    # my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};
    my $newer_only = delete $opts{newer_only};
    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    # my $relative_links = delete $opts{relative_links};

    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );

    my %get_opts = (map { $_ => delete $opts{$_} }
                    qw(block_size queue_size overwrite conversion
                       resume numbered atomic));

    if ($get_opts{resume} and $get_opts{conversion}) {
        carp "resume option is useless when data conversion has also been requested";
        delete $get_opts{resume};
    }

    my %get_symlink_opts = (map { $_ => $get_opts{$_} }
                            qw(overwrite numbered));

    %opts and _croak_bad_options(keys %opts);

    $remote = $sftp->join($remote, './');
    my $qremote = quotemeta $remote;
    my $reremote = qr/^$qremote(.*)$/i;

    $umask = umask $umask if (defined $umask);

    $copy_perm = 1 unless defined $copy_perm;
    $copy_time = 1 unless defined $copy_time;

    require File::Spec;

    my $count = 0;
    $sftp->find( [$remote],
		 descend => sub {
		     my $e = $_[1];
		     # print "descend: $e->{filename}\n";
		     if (!$wanted or $wanted->($sftp, $e)) {
			 my $fn = $e->{filename};
			 if ($fn =~ $reremote) {
			     my $lpath = File::Spec->catdir($local, $1);
                             ($lpath) = $lpath =~ /(.*)/ if ${^TAINT};
			     if (-d $lpath) {
				 $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
						   "directory '$lpath' already exists");
				 $sftp->_call_on_error($on_error, $e);
				 return 1;
			     }
			     else {
				 if (CORE::mkdir $lpath, ($copy_perm ? $e->{a}->perm & 0777 : 0777)) {
				     $count++;
				     return 1;
				 }
				 else {
				     $sftp->_set_error(SFTP_ERR_LOCAL_MKDIR_FAILED,
						       "mkdir '$lpath' failed", $!);
				 }
			     }
			 }
			 else {
			     $sftp->_set_error(SFTP_ERR_REMOTE_BAD_PATH,
					       "bad remote path '$fn'");
			 }
			 $sftp->_call_on_error($on_error, $e);
		     }
		     return undef;
		 },
		 wanted => sub {
		     my $e = $_[1];
		     # print "file fn:$e->{filename}, a:$e->{a}\n";
		     unless (_is_dir($e->{a}->perm)) {
			 if (!$wanted or $wanted->($sftp, $e)) {
			     my $fn = $e->{filename};
			     if ($fn =~ $reremote) {
				 my $lpath = File::Spec->catfile($local, $1);
                                 ($lpath) = $lpath =~ /(.*)/ if ${^TAINT};
				 if (_is_lnk($e->{a}->perm) and !$ignore_links) {
				     if ($sftp->get_symlink($fn, $lpath,
							    copy_time => $copy_time,
                                                            %get_symlink_opts)) {
					 $count++;
					 return undef;
				     }
				 }
				 elsif (_is_reg($e->{a}->perm)) {
				     if ($newer_only and -e $lpath
					 and (CORE::stat _)[9] >= $e->{a}->mtime) {
					 $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
							   "newer local file '$lpath' already exists");
				     }
				     else {
					 if ($sftp->get($fn, $lpath,
							copy_perm => $copy_perm,
							copy_time => $copy_time,
                                                        %get_opts)) {
					     $count++;
					     return undef;
					 }
				     }
				 }
				 else {
				     $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
						       ( $ignore_links
							 ? "remote file '$fn' is not regular file or directory"
							 : "remote file '$fn' is not regular file, directory or link"));
				 }
			     }
			     else {
				 $sftp->_set_error(SFTP_ERR_REMOTE_BAD_PATH,
						   "bad remote path '$fn'");
			     }
			     $sftp->_call_on_error($on_error, $e);
			 }
		     }
		     return undef;
		 } );

    umask $umask if defined $umask;

    return $count;
}

sub rput {
    @_ >= 2 or croak 'Usage: $sftp->rput($local, $remote, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $local, $remote, %opts) = @_;

    defined $local or croak "local path is undefined";
    $remote = '.' unless defined $remote;

    # my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};

    my $newer_only = delete $opts{newer_only};
    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );

    my %put_opts = (map { $_ => delete $opts{$_} }
		    qw(block_size queue_size overwrite conversion
                       resume numbered late_set_perm atomic));

    my %put_symlink_opts = (map { $_ => $put_opts{$_} }
                            qw(overwrite numbered));

    %opts and _croak_bad_options(keys %opts);

    require Net::SFTP::Foreign::Local;
    my $lfs = Net::SFTP::Foreign::Local->new;

    $local = $lfs->join($local, './');
    my $relocal;
    if ($local =~ m|^\./?$|) {
	$relocal = qr/^(.*)$/;
    }
    else {
	my $qlocal = quotemeta $local;
	$relocal = qr/^$qlocal(.*)$/i;
    }

    $copy_perm = 1 unless defined $copy_perm;
    $copy_time = 1 unless defined $copy_time;

    $umask = umask unless defined $umask;
    my $mask = ~$umask;

    if ($on_error) {
	my $on_error1 = $on_error;
	$on_error = sub {
	    my $lfs = shift;
	    $sftp->_copy_error($lfs);
	    $sftp->_call_on_error($on_error1, @_);
	}
    }

    my $count = 0;
    $lfs->find( [$local],
		descend => sub {
		    my $e = $_[1];
		    # print "descend: $e->{filename}\n";
		    if (!$wanted or $wanted->($lfs, $e)) {
			my $fn = $e->{filename};
			$debug and $debug and 32768 and _debug "rput handling $fn";
			if ($fn =~ $relocal) {
			    my $rpath = $sftp->join($remote, File::Spec->splitdir($1));
			    $debug and $debug and 32768 and _debug "rpath: $rpath";
			    if ($sftp->test_d($rpath)) {
				$lfs->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
						 "Remote directory '$rpath' already exists");
				$lfs->_call_on_error($on_error, $e);
				return 1;
			    }
			    else {
				my $a = Net::SFTP::Foreign::Attributes->new;
				$a->set_perm(($copy_perm ? $e->{a}->perm & 0777 : 0777) & $mask);
				if ($sftp->mkdir($rpath, $a)) {
				    $count++;
				    return 1;
				}
				else {
				    $lfs->_copy_error($sftp);
				}
			    }
			}
			else {
			    $lfs->_set_error(SFTP_ERR_LOCAL_BAD_PATH,
					      "Bad local path '$fn'");
			}
			$lfs->_call_on_error($on_error, $e);
		    }
		    return undef;
		},
		wanted => sub {
		    my $e = $_[1];
		    # print "file fn:$e->{filename}, a:$e->{a}\n";
		    unless (_is_dir($e->{a}->perm)) {
			if (!$wanted or $wanted->($lfs, $e)) {
			    my $fn = $e->{filename};
			    $debug and $debug and 32768 and _debug "rput handling $fn";
			    if ($fn =~ $relocal) {
				my (undef, $d, $f) = File::Spec->splitpath($1);
				my $rpath = $sftp->join($remote, File::Spec->splitdir($d), $f);
				if (_is_lnk($e->{a}->perm) and !$ignore_links) {
				    if ($sftp->put_symlink($fn, $rpath,
                                                           %put_symlink_opts)) {
					$count++;
					return undef;
				    }
				    $lfs->_copy_error($sftp);
				}
				elsif (_is_reg($e->{a}->perm)) {
				    my $ra;
				    if ( $newer_only and
					 $ra = $sftp->stat($rpath) and
					 $ra->mtime >= $e->{a}->mtime) {
					$lfs->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
							 "Newer remote file '$rpath' already exists");
				    }
				    else {
					if ($sftp->put($fn, $rpath,
						       perm => ($copy_perm ? $e->{a}->perm : 0777) & $mask,
						       copy_time => $copy_time,
                                                       %put_opts)) {
					    $count++;
					    return undef;
					}
					$lfs->_copy_error($sftp);
				    }
				}
				else {
				    $lfs->_set_error(SFTP_ERR_LOCAL_BAD_OBJECT,
						      ( $ignore_links
							? "Local file '$fn' is not regular file or directory"
							: "Local file '$fn' is not regular file, directory or link"));
				}
			    }
			    else {
				$lfs->_set_error(SFTP_ERR_LOCAL_BAD_PATH,
						  "Bad local path '$fn'");
			    }
			    $lfs->_call_on_error($on_error, $e);
			}
		    }
		    return undef;
		} );

    return $count;
}

sub mget {
    @_ >= 2 or croak 'Usage: $sftp->mget($remote, $localdir, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $remote, $localdir, %opts) = @_;

    defined $remote or croak "remote pattern is undefined";

    my $on_error = $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my %glob_opts = (map { $_ => delete $opts{$_} }
		     qw(on_error follow_links ignore_case
                        wanted no_wanted strict_leading_dot));

    my %get_symlink_opts = (map { $_ => $opts{$_} }
			    qw(overwrite numbered));

    my %get_opts = (map { $_ => delete $opts{$_} }
		    qw(umask copy_perm copy_time block_size queue_size
                       overwrite conversion resume numbered atomic));

    %opts and _croak_bad_options(keys %opts);

    my @remote = map $sftp->glob($_, %glob_opts), _ensure_list $remote;

    my $count = 0;

    require File::Spec;
    for my $e (@remote) {
	my $perm = $e->{a}->perm;
	if (_is_dir($perm)) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$e->{filename}' is a directory");
	}
	else {
	    my $fn = $e->{filename};
	    my ($local) = $fn =~ m{([^\\/]*)$};

	    $local = File::Spec->catfile($localdir, $local)
		if defined $localdir;

	    if (_is_lnk($perm)) {
		next if $ignore_links;
		$sftp->get_symlink($fn, $local, %get_symlink_opts);
	    }
	    else {
		$sftp->get($fn, $local, %get_opts);
	    }
	}
	$count++ unless $sftp->error;
	$sftp->_call_on_error($on_error, $e);
    }
    $count;
}

sub mput {
    @_ >= 2 or croak 'Usage: $sftp->mput($local, $remotedir, %opts)';

    my ($sftp, $local, $remotedir, %opts) = @_;

    defined $local or die "local pattern is undefined";

    my $on_error = $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my %glob_opts = (map { $_ => delete $opts{$_} }
		     qw(on_error follow_links ignore_case
                        wanted no_wanted strict_leading_dot));
    my %put_symlink_opts = (map { $_ => $opts{$_} }
			    qw(overwrite numbered));

    my %put_opts = (map { $_ => delete $opts{$_} }
		    qw(umask copy_perm copy_time block_size queue_size
                       overwrite conversion resume numbered late_set_perm atomic));

    %opts and _croak_bad_options(keys %opts);

    require Net::SFTP::Foreign::Local;
    my $lfs = Net::SFTP::Foreign::Local->new;
    my @local = map $lfs->glob($_, %glob_opts), _ensure_list $local;

    my $count = 0;
    require File::Spec;
    for my $e (@local) {
	my $perm = $e->{a}->perm;
	if (_is_dir($perm)) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$e->{filename}' is a directory");
	}
	else {
	    my $fn = $e->{filename};
	    my $remote = (File::Spec->splitpath($fn))[2];
	    $remote = $sftp->join($remotedir, $remote)
		if defined $remotedir;

	    if (_is_lnk($perm)) {
		next if $ignore_links;
		$sftp->put_symlink($fn, $remote, %put_symlink_opts);
	    }
	    else {
		$sftp->put($fn, $remote, %put_opts);
	    }
	}
	$count++ unless $sftp->error;
	$sftp->_call_on_error($on_error, $e);
    } 
    $count;
}

sub _get_statvfs {
    my ($sftp, $eid, $error, $errstr) = @_;
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_EXTENDED_REPLY,
                                            $eid, $error, $errstr)) {
        # printf STDERR "msg length: %i\n", length $$msg;
        my %statvfs = map { $_ => $msg->get_int64 } qw(bsize frsize blocks
                                                       bfree bavail files ffree
                                                       favail fsid flag namemax);
        return \%statvfs;
    }
    return undef;
}

sub statvfs {
    @_ == 2 or croak 'Usage: $sftp->statvfs($path)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path) = @_;
    $sftp->_check_extension('statvfs@openssh.com' => 2,
                            SFTP_ERR_REMOTE_STATVFS_FAILED,
                            "statvfs failed")
        or return undef;

    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'statvfs@openssh.com',
                                   str => $sftp->_fs_encode($path));
    $sftp->_get_statvfs($id,
                        SFTP_ERR_REMOTE_STATVFS_FAILED,
                        "Couldn't stat remote file system");
}

sub fstatvfs {
    @_ == 2 or croak 'Usage: $sftp->fstatvfs($fh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $fh) = @_;
    $sftp->_check_extension('fstatvfs@openssh.com' => 2,
                            SFTP_ERR_REMOTE_FSTATVFS_FAILED,
                            "fstatvfs failed")
        or return undef;

    my $rid = $sftp->_rid($fh);
    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'fstatvfs@openssh.com',
                                   str => $rid);
    $sftp->_get_statvfs($id,
                        SFTP_ERR_REMOTE_FSTATVFS_FAILED,
                        "Couldn't stat remote file system");
}

package Net::SFTP::Foreign::Handle;

use Tie::Handle;
our @ISA = qw(Tie::Handle);
our @CARP_NOT = qw(Net::SFTP::Foreign Tie::Handle);

my $gen_accessor = sub {
    my $ix = shift;
    sub {
	my $st = *{shift()}{ARRAY};
	if (@_) {
	    $st->[$ix] = shift;
	}
	else {
	    $st->[$ix]
	}
    }
};

my $gen_proxy_method = sub {
    my $method = shift;
    sub {
	my $self = $_[0];
	$self->_check
	    or return undef;

	my $sftp = $self->_sftp;
	if (wantarray) {
	    my @ret = $sftp->$method(@_);
	    $sftp->_set_errno unless @ret;
	    return @ret;
	}
	else {
	    my $ret = $sftp->$method(@_);
	    $sftp->_set_errno unless defined $ret;
	    return $ret;
	}
    }
};

my $gen_not_supported = sub {
    sub {
	$! = Errno::ENOTSUP();
	undef
    }
};

sub TIEHANDLE { return shift }

# sub UNTIE {}

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift || 0;

    my $self = Symbol::gensym;
    bless $self, $class;
    *$self = [ $sftp, $rid, 0, $flags, @_];
    tie *$self, $self;

    $self;
}

sub _close {
    my $self = shift;
    @{*{$self}{ARRAY}} = ();
}

sub _check {
    return 1 if defined(*{shift()}{ARRAY}[0]);
    $! = Errno::EBADF;
    undef;
}

sub FILENO {
    my $self = shift;
    $self->_check
	or return undef;

    my $hrid = unpack 'H*' => $self->_rid;
    "-1:sftp(0x$hrid)"
}

sub _sftp { *{shift()}{ARRAY}[0] }
sub _rid { *{shift()}{ARRAY}[1] }

* _pos = $gen_accessor->(2);

sub _inc_pos {
    my ($self, $inc) = @_;
    *{shift()}{ARRAY}[2] += $inc;
}


my %flag_bit = (append => 0x1);

sub _flag {
    my $st = *{shift()}{ARRAY};
    my $fn = shift;
    my $flag = $flag_bit{$fn};
    Carp::croak("unknown flag $fn") unless defined $flag;
    if (@_) {
	if (shift) {
	    $st->[3] |= $flag;
	}
	else {
	    $st->[3] &= ~$flag;
	}
    }
    $st->[3] & $flag ? 1 : 0
}

sub _check_is_file {
    Carp::croak("expecting remote file handler, got directory handler");
}
sub _check_is_dir {
    Carp::croak("expecting remote directory handler, got file handler");
}

my $autoloaded;
sub AUTOLOAD {
    my $self = shift;
    our $AUTOLOAD;
    if ($autoloaded) {
	my $class = ref $self || $self;
	Carp::croak qq|Can't locate object method "$AUTOLOAD" via package "$class|;
    }
    else {
	$autoloaded = 1;
	require IO::File;
	require IO::Dir;
	my ($method) = $AUTOLOAD =~ /^.*::(.*)$/;
	$self->$method(@_);
    }
}

package Net::SFTP::Foreign::FileHandle;
our @ISA = qw(Net::SFTP::Foreign::Handle IO::File);

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift;

    my $self = $class->SUPER::_new_from_rid($sftp, $rid, $flags, '', '');
}

sub _check_is_file {}

sub _bin { \(*{shift()}{ARRAY}[4]) }
sub _bout { \(*{shift()}{ARRAY}[5]) }

sub WRITE {
    my ($self, undef, $length, $offset) = @_;
    $self->_check
	or return undef;

    $offset = 0 unless defined $offset;
    $offset = length $_[1] + $offset if $offset < 0;
    $length = length $_[1] unless defined $length;

    my $sftp = $self->_sftp;

    my $ret = $sftp->write($self, substr($_[1], $offset, $length));
    $sftp->_set_errno unless defined $ret;
    $ret;
}

sub READ {
    my ($self, undef, $len, $offset) = @_;
    $self->_check
	or return undef;

    $_[1] = '' unless defined $_[1];
    $offset ||= 0;
    if ($offset > length $_[1]) {
	$_[1] .= "\0" x ($offset - length $_[1])
    }

    if ($len == 0) {
	substr($_[1], $offset) = '';
	return 0;
    }

    my $sftp = $self->_sftp;
    $sftp->_fill_read_cache($self, $len);

    my $bin = $self->_bin;
    if (length $$bin) {
	my $data = substr($$bin, 0, $len, '');
	$self->_inc_pos($len);
	substr($_[1], $offset) = $data;
	return length $data;
    }
    return 0 if $sftp->{_status} == $sftp->SSH2_FX_EOF;
    $sftp->_set_errno;
    undef;
}

sub EOF {
    my $self = $_[0];
    $self->_check or return undef;
    my $sftp = $self->_sftp;
    my $ret = $sftp->eof($self);
    $sftp->_set_errno unless defined $ret;
    $ret;
}

*GETC = $gen_proxy_method->('getc');
*TELL = $gen_proxy_method->('tell');
*SEEK = $gen_proxy_method->('seek');
*CLOSE = $gen_proxy_method->('close');

my $readline = $gen_proxy_method->('readline');
sub READLINE { $readline->($_[0], $/) }

sub OPEN {
    shift->CLOSE;
    undef;
}

sub DESTROY {
    my $self = shift;
    my $sftp = $self->_sftp;

    $debug and $debug & 4 and Net::SFTP::Foreign::_debug("$self->DESTROY called (sftp: ".($sftp||'').")");

    if ($self->_check and $sftp) {
        local $sftp->{_autodie};
	$sftp->_close_save_status($self)
    }
}

package Net::SFTP::Foreign::DirHandle;
our @ISA = qw(Net::SFTP::Foreign::Handle IO::Dir);

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift;

    my $self = $class->SUPER::_new_from_rid($sftp, $rid, $flags, []);
}


sub _check_is_dir {}

sub _cache { *{shift()}{ARRAY}[4] }

*CLOSEDIR = $gen_proxy_method->('closedir');
*READDIR = $gen_proxy_method->('_readdir');

sub OPENDIR {
    shift->CLOSEDIR;
    undef;
}

*REWINDDIR = $gen_not_supported->();
*TELLDIR = $gen_not_supported->();
*SEEKDIR = $gen_not_supported->();

sub DESTROY {
    my $self = shift;
    my $sftp = $self->_sftp;

    $debug and $debug & 4 and Net::SFTP::Foreign::_debug("$self->DESTROY called (sftp: ".($sftp||'').")");

    if ($self->_check and $sftp) {
        local $sftp->{_autodie};
	$sftp->_closedir_save_status($self)
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign - SSH File Transfer Protocol client

=head1 SYNOPSIS

    use Net::SFTP::Foreign;
    my $sftp = Net::SFTP::Foreign->new($host);
    $sftp->die_on_error("Unable to establish SFTP connection");

    $sftp->setcwd($path) or die "unable to change cwd: " . $sftp->error;

    $sftp->get("foo", "bar") or die "get failed: " . $sftp->error;

    $sftp->put("bar", "baz") or die "put failed: " . $sftp->error;

=head1 DESCRIPTION

SFTP stands for SSH File Transfer Protocol and is a method of
transferring files between machines over a secure, encrypted
connection (as opposed to regular FTP, which functions over an
insecure connection). The security in SFTP comes through its
integration with SSH, which provides an encrypted transport layer over
which the SFTP commands are executed.

Net::SFTP::Foreign is a Perl client for the SFTP version 3 as defined
in the SSH File Transfer Protocol IETF draft, which can be found at
L<http://www.openssh.org/txt/draft-ietf-secsh-filexfer-02.txt> (also
included on this package distribution, on the C<rfc> directory).

Net::SFTP::Foreign uses any compatible C<ssh> command installed on
the system (for instance, OpenSSH C<ssh>) to establish the secure
connection to the remote server.

A wrapper module L<Net::SFTP::Foreign::Compat> is also provided for
compatibility with L<Net::SFTP>.


=head2 Net::SFTP::Foreign Vs. Net::SFTP Vs. Net::SSH2::SFTP

Why should I prefer Net::SFTP::Foreign over L<Net::SFTP>?

Well, both modules have their pros and cons:

Net::SFTP::Foreign does not require a bunch of additional modules and
external libraries to work, just the OpenBSD SSH client (or any other
client compatible enough).

I trust OpenSSH SSH client more than L<Net::SSH::Perl>, there are lots
of paranoid people ensuring that OpenSSH doesn't have security
holes!!!

If you have an SSH infrastructure already deployed, by using the same
binary SSH client, Net::SFTP::Foreign ensures a seamless integration
within your environment (configuration files, keys, etc.).

Net::SFTP::Foreign is much faster transferring files, specially over
networks with high (relative) latency.

Net::SFTP::Foreign provides several high level methods not available
from Net::SFTP as for instance C<find>, C<glob>, C<rget>, C<rput>,
C<rremove>, C<mget>, C<mput>.

On the other hand, using the external command means an additional
proccess being launched and running, depending on your OS this could
eat more resources than the in process pure perl implementation
provided by L<Net::SSH::Perl>.

L<Net::SSH2> is a module wrapping libssh2, an SSH version 2 client
library written in C. It is a very active project that aims to replace
L<Net::SSH::Perl>. Unfortunately, libssh2 SFTP functionality
(available in Perl via L<Net::SSH2::SFTP>) is rather limited and its
performance very poor.

Later versions of Net::SFTP::Foreign can use L<Net::SSH2> as the
transport layer via the backend module
L<Net::SFTP::Foreign::Backend::Net_SSH2>.

=head2 Error handling

Most of the methods available from this package return undef on
failure and a true value or the requested data on
success. C<$sftp-E<gt>error> should be used to check for errors
explicitly after every method call. For instance:

  $sftp = Net::SFTP::Foreign->new($host);
  $sftp->error and die "unable to connect to remote host: " . $sftp->error;

Also, the L</die_on_error> method provides a handy shortcut for the last line:

  $sftp = Net::SFTP::Foreign->new($host);
  $sftp->die_on_error("unable to connect to remote host");

Alternatively, the C<autodie> mode that makes the module die when any
error is found can be activated from the constructor. For instance:

  $sftp = Net::SFTP::Foreign->new($host, autodie => 1);
  my $ls = $sftp->ls("/bar");
  # dies as: "Couldn't open remote dir '/bar': No such file"

The C<autodie> mode will be disabled when an C<on_error> handler is
passed to methods accepting it:

  my $sftp = Net::SFTP::Foreign->new($host, autodie => 1);
  # prints "foo!" and does not die:
  $sftp->find("/sdfjkalshfl", # nonexistent directory
              on_error => sub { print "foo!\n" });
  # dies:
  $sftp->find("/sdfjkalshfl");

=head2 API

The methods available from this module are described below.

Don't forget to read also the FAQ and BUGS sections at the end of this
document!

=over 4

=item Net::SFTP::Foreign->new($host, %args)

=item Net::SFTP::Foreign->new(%args)

Opens a new SFTP connection with a remote host C<$host>, and returns a
Net::SFTP::Foreign object representing that open connection.

An explicit check for errors should be included always after the
constructor call:

  my $sftp = Net::SFTP::Foreign->new(...);
  $sftp->die_on_error("SSH connection failed");

The optional arguments accepted are as follows:

=over 4

=item host =E<gt> $hostname

remote host name

=item user =E<gt> $username

username to log in to the remote server. This should be your SSH
login, and can be empty, in which case the username is drawn from the
user executing the process.

=item port =E<gt> $portnumber

port number where the remote SSH server is listening

=item ssh1 =E<gt> 1

use old SSH1 approach for starting the remote SFTP server.

=item more =E<gt> [@more_ssh_args]

additional args passed to C<ssh> command.

For debugging purposes you can run C<ssh> in verbose mode passing it
the C<-v> option:

  my $sftp = Net::SFTP::Foreign->new($host, more => '-v');

Note that this option expects a single command argument or a reference
to an array of arguments. For instance:

  more => '-v'         # right
  more => ['-v']       # right
  more => "-c $cipher"    # wrong!!!
  more => [-c => $cipher] # right

=item timeout =E<gt> $seconds

when this parameter is set, the connection is dropped if no data
arrives on the SSH socket for the given time while waiting for some
command to complete.

When the timeout expires, the current method is aborted and
the SFTP connection becomes invalid.

=item fs_encoding =E<gt> $encoding

Version 3 of the SFTP protocol (the one supported by this module)
knows nothing about the character encoding used on the remote
filesystem to represent file and directory names.

This option allows to select the encoding used in the remote
machine. The default value is C<utf8>.

For instance:

  $sftp = Net::SFTP::Foreign->new('user@host', fs_encoding => 'latin1');

will convert any path name passed to any method in this package to its
C<latin1> representation before sending it to the remote side.

Note that this option will not affect file contents in any way.

This feature is not supported in perl 5.6 due to incomplete Unicode
support in the interpreter.

=item key_path =E<gt> $filename

asks C<ssh> to use the key in the given file for authentication.

=item password =E<gt> $password

=item passphrase =E<gt> $passphrase

uses L<Expect> to handle password authentication or keys requiring a
passphrase.

Note that password authentication on Windows OSs only works when the
Cygwin port of Perl is used.

=item expect_log_user =E<gt> $bool

activates password/passphrase authentication interaction logging (see
C<Expect::log_user> method documentation).

=item ssh_cmd =E<gt> $sshcmd

=item ssh_cmd =E<gt> \@sshcmd

name of the external SSH client. By default C<ssh> is used.

For instance:

  $sftp = Net::SFTP::Foreign->new($host, ssh_cmd => 'plink');

When an array reference is used, its elements are inserted at the
beginning of the system call. That allows, for instance, to connect to
the target host through some SSH proxy:

  $sftp = Net::SFTP::Foreign->new($host,
              ssh_cmd => qw(ssh -l user proxy.server ssh));

But note that the module will not handle password authentication for
those proxies.

=item ssh_cmd_interface =E<gt> 'plink' or 'ssh' or 'tectia'

declares the command line interface that the SSH client used to
connect to the remote host understands. Currently C<plink>, C<ssh> and
C<tectia> are supported.

This option would be rarely required as the module infers the
interface from the SSH command name.

=item transport =E<gt> $fh

=item transport =E<gt> [$in_fh, $out_fh]

=item transport =E<gt> [$in_fh, $out_fh, $pid]

allows to use an already open pipe or socket as the transport for the
SFTP protocol.

It can be (ab)used to make this module work with password
authentication or with keys requiring a passphrase.

C<in_fh> is the file handler used to read data from the remote server,
C<out_fh> is the file handler used to write data.

On some systems, when using a pipe as the transport, closing it, does
not cause the process at the other side to exit. The additional
C<$pid> argument can be used to instruct this module to kill that
process if it doesn't exit by itself.

=item open2_cmd =E<gt> [@cmd]

=item open2_cmd =E<gt> $cmd;

allows to completely redefine how C<ssh> is called. Its arguments are
passed to L<IPC::Open2::open2> to open a pipe to the remote
server.

=item stderr_fh =E<gt> $fh

redirects the output sent to stderr by the SSH subprocess to the given
file handle.

It can be used to suppress banners:

  open my $ssherr, '>', '/dev/null' or die "unable to open /dev/null";
  my $sftp = Net::SFTP::Foreign->new($host,
                                     stderr_fh => $ssherr);

Or to send SSH stderr to a file in order to capture errors for later
analysis:

  my $ssherr = File::Temp->new or die "File::Temp->new failed";
  my $sftp = Net::SFTP::Foreign->new($hostname, more => ['-v'],
                                     stderr_fh => $ssherr);
  if ($sftp->error) {
    print "sftp error: ".$sftp->error."\n";
    seek($ssherr, 0, 0);
    while (<$ssherr>) {
      print "captured stderr: $_";
    }
  }

=item stderr_discard =E<gt> 1

redirects stderr to /dev/null

=item block_size =E<gt> $default_block_size

=item queue_size =E<gt> $default_queue_size

default C<block_size> and C<queue_size> used for read and write
operations (see the C<put> or C<get> documentation).

=item autoflush =E<gt> $bool

by default, and for performance reasons, write operations are cached,
and only when the write buffer becomes big enough is the data written to
the remote file. Setting this flag makes the write operations inmediate.

=item write_delay =E<gt> $bytes

This option determines how many bytes are buffered before the real
SFTP write operation is performed.

=item read_ahead =E<gt> $bytes

On read operations this option determines how many bytes to read in
advance so that later read operations can be fulfilled from the
buffer.

Using a high value will increase the performance of the module for a
sequential reads access pattern but degrade it for a short random
reads access pattern. It can also cause synchronization problems if
the file is concurrently modified by other parties (L</flush> can be
used to discard all the data inside the read buffer on demand).

The default value is set dynamically considering some runtime
parameters and given options, though it tends to favor the sequential
read access pattern.

=item autodisconnect =E<gt> $ad

by default, the SSH connection is closed from the DESTROY method when
the object goes out of scope. But on scripts that fork new processes,
that results on the SSH connection being closed by the first process
where the object goes out of scope, something undesirable.

This option allows to work-around this issue to some extend.

The acceptable values for C<$ad> are:

=over 4

=item 0

Never try to disconnect this object when exiting from any process.

On most operating systems, the SSH process will exit when the last
process connected to it ends, but this is not guaranteed.

=item 1

Disconnect on exit from any process. This is the default.

=item 2

Disconnect on exit from the current process only.

=back

See also the disconnect and autodisconnect methods.

=item late_set_perm =E<gt> $bool

See the FAQ below.

=item dirty_cleanup =E<gt> $bool

Sets the C<dirty_cleanup> flag in a per object basis (see the BUGS
section).

=item backend => $backend

From version 1.57 Net::SFTP::Foreign supports plugable backends in
order to allow other ways to comunicate with the remote server in
addition to the default I<pipe-to-ssh-process>.

Custom backends may change the set of options supported by the C<new>
method.

=item autodie => $bool

Enables the autodie mode that will cause the module to die when any
error is found (a la L<autodie>).

=back

=item $sftp-E<gt>error

Returns the error code from the last executed command. The value
returned is similar to C<$!>, when used as a string it yields the
corresponding error string.

See L<Net::SFTP::Foreign::Constants> for a list of possible error
codes and how to import them on your scripts.

=item $sftp-E<gt>die_on_error($msg)

Convenience method:

  $sftp->die_on_error("Something bad happened");
  # is a shortcut for...
  $sftp->error and die "Something bad happened: " . $sftp->error;

=item $sftp-E<gt>status

Returns the code from the last SSH2_FXP_STATUS response. It is also a
dualvar that yields the status string when used as a string.

Usually C<$sftp-E<gt>error> should be checked first to see if there was
any error and then C<$sftp-E<gt>status> to find out its low level cause.

=item $sftp-E<gt>cwd

Returns the remote current working directory.

When a relative remote path is passed to any of the methods on this
package, this directory is used to compose the absolute path.

=item $sftp-E<gt>setcwd($dir)

Changes the remote current working directory. The remote directory
should exist, otherwise the call fails.

Returns the new remote current working directory or undef on failure.

=item $sftp-E<gt>get($remote, $local, %options)

X<get>Copies remote file C<$remote> to local $local. By default file
attributes are also copied (permissions, atime and mtime). For
instance:

  $sftp->get('/var/log/messages', /tmp/messages')
    or die "file transfer failed: " . $sftp->error;

A file handle can also be used as the local target. In that case, the
remote file contents are retrieved and written to the given file
handle. Note also that the handle is not closed when the transmission
finish.

  open F, '| gzip -c > /tmp/foo' or die ...;
  $sftp->get("/etc/passwd", \*F)
    or die "get failed: " . $sftp->error;
  close F or die ...;

Accepted options (not all combinations are possible):

=over 4

=item copy_time =E<gt> $bool

determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.

=item copy_perm =E<gt> $bool

determines if permision attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.

=item umask =E<gt> $umask

allows to select the umask to apply when setting the permissions of
the copied file. Default is to use the umask for the current process.

=item perm =E<gt> $perm

sets the permision mask of the file to be $perm, umask and remote
permissions are ignored.

=item resume =E<gt> 1 | 'auto'

resumes an interrupted transfer.

If the C<auto> value is given, the transfer will be resumed only when
the local file is newer than the remote one.

C<get> transfers can not be resumed when a data conversion is in
place.

=item append =E<gt> 1

appends the contents of the remote file at the end of the local one
instead of overwriting it. If the local file does not exist a new one
is created.

=item overwrite =E<gt> 0

setting this option to zero cancels the transfer when a local file of
the same name already exists.

=item numbered =E<gt> 1

modifies the local file name inserting a sequence number when required
in order to avoid overwriting local files.

For instance:

  for (1..2) {
    $sftp->get("data.txt", "data.txt", numbered => 1);
  }

will copy the remote file as "data.txt" the first time and as
"data(1).txt" the second one.

If a scalar reference is passed as the numbered value, the final
target will be stored in the value pointed by the reference. For
instance:

  my $target;
  $sftp->get("data.txt", "data.txt", numbered => \$target);
  say "file was saved as $target" unless $sftp->error

=item atomic =E<gt> 1

The remote file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.

If not-overwrite of remote files is also requested, an empty file may
appear at the target destination before the rename operation is
performed. This is due to limitations of some operating/file systems.

=item cleanup =E<gt> 1

If the transfer fails, remove the incomplete file.

This option is set to by default when there is not possible to resume
the transfer afterwards (i.e., when using `atomic` or `numbered`
options).

=item conversion =E<gt> $conversion

on the fly data conversion of the file contents can be performed with
this option. See L</On the fly data conversion> below.

=item callback =E<gt> $callback

C<$callback> is a reference to a subroutine that will be called after
every iteration of the download process.

The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data read from the remote file; the
offset from the beginning of the file in bytes; and the total size of
the file in bytes.

This mechanism can be used to provide status messages, download
progress meters, etc.:

    sub callback {
        my($sftp, $data, $offset, $size) = @_;
        print "Read $offset / $size bytes\r";
    }

The C<abort> method can be called from inside the callback to abort
the transfer:

    sub callback {
        my($sftp, $data, $offset, $size) = @_;
        if (want_to_abort_transfer()) {
            $sftp->abort("You wanted to abort the transfer");
        }
    }

The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.

The size argument can change between different calls as data is
transferred (for instance, when on-the-fly data conversion is being
performed or when the size of the file can not be retrieved with the
C<stat> SFTP command before the data transfer starts).

=item block_size =E<gt> $bytes

size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but some servers limit
the maximum size.

=item queue_size =E<gt> $size

read and write requests are pipelined in order to maximize transfer
throughput. This option allows to set the maximum number of requests
that can be concurrently waiting for a server response.

=back

=item $sftp-E<gt>get_content($remote)

Returns the content of the remote file.

=item $sftp-E<gt>get_symlink($remote, $local, %opts)

copies a symlink from the remote server to the local file system

The accepted options are C<overwrite> and C<numbered>. They have the
same effect as for the C<get> method.

=item $sftp-E<gt>put($local, $remote, %opts)

Uploads a file C<$local> from the local host to the remote host, and
saves it as C<$remote>. By default file attributes are also
copied. For instance:

  $sftp->put("test.txt", "test.txt")
    or die "put failed: " . $sftp->error;

A file handle can also be passed in the C<$local> argument. In that
case, data is read from there and stored in the remote file. UTF8 data
is not supported unless a custom converter callback is used to
transform it to bytes and the method will croak if it encounters any
data in perl internal UTF8 format. Note also that the handle is not
closed when the transmission finish.

Example:

  binmode STDIN;
  $sftp->put(\*STDIN, "stdin.dat") or die "put failed";
  close STDIN;

This method accepts several options:

=over 4

=item copy_time =E<gt> $bool

determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.

=item copy_perm =E<gt> $bool

determines if permision attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.

=item umask =E<gt> $umask

allows to select the umask to apply when setting the permissions of
the copied file. Default is to use the umask for the current process.

=item perm =E<gt> $perm

sets the permision mask of the file to be $perm, umask and local
permissions are ignored.

=item overwrite =E<gt> 0

by default C<put> will overwrite any pre-existent file with the same
name at the remote side. Setting this flag to zero will make the
method fail in that case.

=item numbered =E<gt> 1

when required, adds a sequence number to local file names in order to
avoid overwriting pre-existent files. Off by default.

=item append =E<gt> 1

appends the local file at the end of the remote file instead of
overwriting it. If the remote file does not exist a new one is
created. Off by default.

=item resume =E<gt> 1 | 'auto'

resumes an interrupted transfer.

If the C<auto> value is given, the transfer will be resumed only when
the remote file is newer than the local one.

=item atomic =E<gt> 1

The local file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.

This operation relies on the SSH server to perform an
overwriting/non-overwritting atomic rename operation free of race
conditions.

OpenSSH server does it correctly on top of Linux/UNIX native file
systems (i.e. ext[234], ffs or zfs) but has problems on file systems
not supporting hard links (i.e. FAT) or on operating systems with
broken POSIX semantics as Windows.

=item cleanup =E<gt> 1

If the transfer fails, attempts to remove the incomplete file.

Cleanup may fail if for example the SSH connection gets broken.

This option is set to by default when there is not possible to resume
the transfer afterwards (i.e., when using `atomic` or `numbered`
options).


=item conversion =E<gt> $conversion

on the fly data conversion of the file contents can be performed with
this option. See L</On the fly data conversion> below.

=item callback =E<gt> $callback

C<$callback> is a reference to a subrutine that will be called after
every iteration of the upload process.

The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data that is going to be written to the
remote file; the offset from the beginning of the file in bytes; and
the total size of the file in bytes.

The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.

The size argument can change between calls as data is transferred (for
instance, when on the fly data conversion is being performed).

This mechanism can be used to provide status messages, download
progress meters, etc.

The C<abort> method can be called from inside the callback to abort
the transfer.

=item block_size =E<gt> $bytes

size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but some servers limit
its size and if this limit is overpassed the command will fail.

=item queue_size =E<gt> $size

read and write requests are pipelined in order to maximize transfer
throughput. This option allows to set the maximum number of requests
that can be concurrently waiting for a server response.

=item late_set_perm =E<gt> $bool

See the FAQ below.

=back

=item $sftp-E<gt>put_symlink($local, $remote, %opts)

copies a local symlink to the remote host.

The accepted options are C<overwrite> and C<numbered>.

=item $sftp-E<gt>abort()

=item $sftp-E<gt>abort($msg)

This method, when called from inside a callback sub, causes the
current transfer to be aborted

The error state is set to SFTP_ERR_ABORTED and the optional $msg
argument is used as its textual value.

=item $sftp-E<gt>ls($remote, %opts)

Fetches a listing of the remote directory C<$remote>. If C<$remote> is
not given, the current remote working directory is listed.

Returns a reference to a list of entries. Every entry is a reference
to a hash with three keys: C<filename>, the name of the entry;
C<longname>, an entry in a "long" listing like C<ls -l>; and C<a>, a
L<Net::SFTP::Foreign::Attributes> object containing file atime, mtime,
permissions and size.

    my $ls = $sftp->ls('/home/foo')
        or die "unable to retrieve directory: ".$sftp->error;

    print "$_->{filename}\n" for (@$ls);



The options accepted by this method are as follows (note that usage of
some of them can degrade the method performance when reading large
directories):

=over 4

=item wanted =E<gt> qr/.../

Only elements whose filename matchs the regular expression are included
on the listing.

=item wanted =E<gt> sub {...}

Only elements for which the callback returns a true value are included
on the listing. The callback is called with two arguments: the
C<$sftp> object and the current entry (a hash reference as described
before). For instance:

  use Fcntl ':mode';

  my $files = $sftp->ls ( '/home/hommer',
			  wanted => sub {
			      my $entry = $_[1];
			      S_ISREG($entry->{a}->perm)
			  } )
	or die "ls failed: ".$sftp->error;


=item no_wanted =E<gt> qr/.../

=item no_wanted =E<gt> sub {...}

those options have the oposite result to their C<wanted> counterparts:

  my $no_hidden = $sftp->ls( '/home/homer',
			     no_wanted => qr/^\./ )
	or die "ls failed";


When both C<no_wanted> and C<wanted> rules are used, the C<no_wanted>
rule is applied first and then the C<wanted> one (order is important
if the callbacks have side effects, experiment!).

=item ordered =E<gt> 1

the list of entries is ordered by filename.

=item follow_links =E<gt> 1

by default, the attributes on the listing correspond to a C<lstat>
operation, setting this option causes the method to perform C<stat>
requests instead. C<lstat> attributes will stil appear for links
pointing to non existant places.

=item atomic_readdir =E<gt> 1

reading a directory is not an atomic SFTP operation and the protocol
draft does not define what happens if C<readdir> requests and write
operations (for instance C<remove> or C<open>) affecting the same
directory are intermixed.

This flag ensures that no callback call (C<wanted>, C<no_wanted>) is
performed in the middle of reading a directory and has to be set if
any of the callbacks can modify the file system.

=item realpath =E<gt> 1

for every file object, performs a realpath operation and populates the
C<realpath> entry.

=item names_only =E<gt> 1

makes the method return a simple array containing the file names from
the remote directory only. For instance, these two sentences are
equivalent:

  my @ls1 = @{ $sftp->ls('.', names_only => 1) };

  my @ls2 = map { $_->{filename} } @{$sftp->ls('.')};

=back

=item $sftp-E<gt>find($path, %opts)

=item $sftp-E<gt>find(\@paths, %opts)

X<find>Does a recursive search over the given directory C<$path> (or
directories C<@path>) and returns a list of the entries found or the
total number of them on scalar context.

Every entry is a reference to a hash with two keys: C<filename>, the
full path of the entry; and C<a>, a L<Net::SFTP::Foreign::Attributes>
object containing file atime, mtime, permissions and size.

This method tries to recover and continue under error conditions.

The options accepted:

=over 4

=item on_error =E<gt> sub { ... }

the callback is called when some error is detected, two arguments are
passed: the C<$sftp> object and the entry that was being processed
when the error happened. For instance:

  my @find = $sftp->find( '/',
			  on_error => sub {
			      my ($sftp, $e) = @_;
		 	      print STDERR "error processing $e->{filename}: "
				   . $sftp->error;
			  } );

=item realpath =E<gt> 1

calls method C<realpath> for every entry, the result is stored under
the key C<realpath>. This option slows down the process as a new
remote query is performed for every entry, specially on networks with
high latency.

=item follow_links =E<gt> 1

By default symbolic links are not resolved and appear as that on the
final listing. This option causes then to be resolved and substituted
by the target file system object. Dangling links are ignored, though
they generate a call to the C<on_error> callback when stat'ing them
fails.

Following sym links can introduce loops on the search. Infinite loops
are detected and broken but files can still appear repeated on the
final listing under different names unless the option C<realpath> is
also actived.

=item ordered =E<gt> 1

By default, the file system is searched in an implementation dependent
order (actually optimized for low memory comsumption). If this option
is included, the file system is searched in a deep-first, sorted by
filename fashion.

=item wanted =E<gt> qr/.../

=item wanted =E<gt> sub { ... }

=item no_wanted =E<gt> qr/.../

=item no_wanted =E<gt> sub { ... }

These options have the same effect as on the C<ls> method, allowing to
filter out unwanted entries (note that filename keys contain B<full
paths> here).

The callbacks can also be used to perform some action instead of
creating the full listing of entries in memory (that could use huge
amounts of RAM for big file trees):

  $sftp->find($src_dir,
	      wanted => sub {
		  my $fn = $_[1]->{filename}
		  print "$fn\n" if $fn =~ /\.p[ml]$/;
		  return undef # so it is discarded
	      });

=item descend =E<gt> qr/.../

=item descend =E<gt> sub { ... }

=item no_descend =E<gt> qr/.../

=item no_descend =E<gt> sub { ... }

These options, similar to the C<wanted> ones, allow to prune the
search, discarding full subdirectories. For instance:

    use Fcntl ':mode';
    my @files = $sftp->find( '.',
			     no_descend => qr/\.svn$/,
			     wanted => sub {
				 S_ISREG($_[1]->{a}->perm)
			     } );


C<descend> and C<wanted> rules are unrelated. A directory discarded by
a C<wanted> rule will still be recursively searched unless it is also
discarded on a C<descend> rule and vice-versa.

=item atomic_readdir =E<gt> 1

see C<ls> method documentation.

=item names_only =E<gt> 1

makes the method return a list with the names of the files only (see C<ls>
method documentation).

equivalent:

  my $ls1 = $sftp->ls('.', names_only => 1);

=back

=item $sftp-E<gt>glob($pattern, %opts)

X<glob>performs a remote glob and returns the list of matching entries
in the same format as the L</find> method.

This method tries to recover and continue under error conditions.

The given pattern can be a Unix style pattern (see L<glob(7)>) or a
Regexp object (i.e C<qr/foo/>). In the later case, only files on the
current working directory will be matched against the Regexp.

Accepted options:

=over 4

=item ignore_case =E<gt> 1

by default the matching over the file system is carried out in a case
sensitive fashion, this flag changes it to be case insensitive.

This flag is ignored when a Regexp object is used as the pattern.

=item strict_leading_dot =E<gt> 0

by default, a dot character at the beginning of a file or directory
name is not matched by willcards (C<*> or C<?>). Setting this flags to
a false value changes this behaviour.

This flag is ignored when a Regexp object is used as the pattern.

=item follow_links =E<gt> 1

=item ordered =E<gt> 1

=item names_only =E<gt> 1

=item realpath =E<gt> 1

=item on_error =E<gt> sub { ... }

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

these options perform as on the C<ls> method.

=back

Some usage samples:

  my $files = $sftp->glob("*/lib");

  my $files = $sftp->glob("/var/log/dmesg.*.gz");

  $sftp->set_cwd("/var/log");
  my $files = $sftp->glob(qr/^dmesg\.[\d+]\.gz$/);

  my $files = $sftp->glob("*/*.pdf", strict_leading_dot => 0);

=item $sftp-E<gt>rget($remote, $local, %opts)

Recursively copies the contents of remote directory C<$remote> to
local directory C<$local>. Returns the total number of elements
(files, dirs and symbolic links) successfully copied.

This method tries to recover and continue when some error happens.

The options accepted are:

=over 4

=item umask =E<gt> $umask

use umask C<$umask> to set permissions on the files and directories
created.

=item copy_perm =E<gt> $bool;

if set to a true value, file and directory permissions are copied to
the remote server (after applying the umask). On by default.

=item copy_time =E<gt> $bool;

if set to a true value, file atime and mtime are copied from the
remote server. By default it is on.

=item overwrite =E<gt> $bool

if set to a true value, when a local file with the same name
already exists it is overwritten. On by default.

=item numbered =E<gt> $bool

when required, adds a sequence number to local file names in order to
avoid overwriting pre-existent remote files. Off by default.

=item newer_only =E<gt> $bool

if set to a true value, when a local file with the same name
already exists it is overwritten only if the remote file is newer.

=item ignore_links =E<gt> $bool

if set to a true value, symbolic links are not copied.

=item on_error =E<gt> sub { ... }

the passed sub is called when some error happens. It is called with two
arguments, the C<$sftp> object and the entry causing the error.

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

This option allows to select which files and directories have to be
copied. See also C<ls> method docs.

If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).

=item atomic =E<gt> 1

=item block_size =E<gt> $block_size

=item queue_size =E<gt> $queue_size

=item conversion =E<gt> $conversion

=item resume =E<gt> $resume

See C<get> method docs.

=back

=item $sftp-E<gt>rput($local, $remote, %opts)

Recursively copies the contents of local directory C<$local> to
remote directory C<$remote>.

This method tries to recover and continue when some error happens.

Accepted options are:

=over 4

=item umask =E<gt> $umask

use umask C<$umask> to set permissions on the files and directories
created.

=item copy_perm =E<gt> $bool;

if set to a true value, file and directory permissions are copied
to the remote server (after applying the umask). On by default.

=item copy_time =E<gt> $bool;

if set to a true value, file atime and mtime are copied to the
remote server. On by default.

=item overwrite =E<gt> $bool

if set to a true value, when a remote file with the same name already
exists it is overwritten. On by default.

=item newer_only =E<gt> $bool

if set to a true value, when a remote file with the same name already exists it is
overwritten only if the local file is newer.

=item ignore_links =E<gt> $bool

if set to a true value, symbolic links are not copied

=item on_error =E<gt> sub { ... }

the passed sub is called when some error happens. It is called with two
arguments, the C<$sftp> object and the entry causing the error.

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

This option allows to select which files and directories have to be
copied. See also C<ls> method docs.

If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).

=item atomic =E<gt> 1

=item block_size =E<gt> $block_size

=item queue_size =E<gt> $queue_size

=item conversion =E<gt> $conversion

=item resume =E<gt> $resume

=item late_set_perm =E<gt> $bool

see C<put> method docs.

=back

=item $sftp-E<gt>rremove($dir, %opts)

=item $sftp-E<gt>rremove(\@dirs, %opts)

recursively remove directory $dir (or directories @dirs) and its
contents. Returns the number of elements successfully removed.

This method tries to recover and continue when some error happens.

The options accepted are:

=over 4

=item on_error =E<gt> sub { ... }

This callback is called when some error is occurs. The arguments
passed are the C<$sftp> object and the current entry (see C<ls> docs
for more information).

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

Allow to select which file system objects have to be deleted.

=back

=item $sftp-E<gt>mget($remote, $localdir, %opts)

=item $sftp-E<gt>mget(\@remote, $localdir, %opts)

X<mget>expands the wildcards on C<$remote> or C<@remote> and retrieves
all the matching files.

For instance:

  $sftp->mget(['/etc/hostname.*', '/etc/init.d/*'], '/tmp');

The method accepts all the options valid for L</glob> and for L</get>
(except those that do not make sense :-)

C<$localdir> is optional and defaults to the process cwd.

Files are saved with the same name they have in the remote server
excluding the directory parts.

Note that name collisions are not detected. For instance:

 $sftp->mget(["foo/file.txt", "bar/file.txt"], "/tmp")

will transfer the first file to "/tmp/file.txt" and later overwrite it
with the second one. The C<numbered> option can be used to avoid this
issue.

=item $sftp-E<gt>mput($local, $remotedir, %opts)

=item $sftp-E<gt>mput(\@local, $remotedir, %opts)

similar to L</mget> but works in the opposite direction transferring
files from the local side to the remote one.

=item $sftp-E<gt>join(@paths)

returns the given path fragments joined in one path (currently the
remote file system is expected to be Unix like).

=item $sftp-E<gt>open($path, $flags [, $attrs ])

Sends the C<SSH_FXP_OPEN> command to open a remote file C<$path>,
and returns an open handle on success. On failure returns
C<undef>.

The returned value is a tied handle (see L<Tie::Handle>) that can be
used to access the remote file both with the methods available from
this module and with perl built-ins. For instance:

  # reading from the remote file
  my $fh1 = $sftp->open("/etc/passwd")
    or die $sftp->error;
  while (<$fh1>) { ... }

  # writting to the remote file
  use Net::SFTP::Foreign::Constants qw(:flags);
  my $fh2 = $sftp->open("/foo/bar", SSH2_FXF_WRITE|SSH2_FXF_CREAT)
    or die $sftp->error;
  print $fh2 "printing on the remote file\n";
  $sftp->write($fh2, "writting more");

The C<$flags> bitmap determines how to open the remote file as defined
in the SFTP protocol draft (the following constants can be imported
from L<Net::SFTP::Foreign::Constants>):

=over 4

=item SSH2_FXF_READ

Open the file for reading. It is the default mode.

=item SSH2_FXF_WRITE

Open the file for writing.  If both this and C<SSH2_FXF_READ> are
specified, the file is opened for both reading and writing.

=item SSH2_FXF_APPEND

Force all writes to append data at the end of the file.

As OpenSSH SFTP server implementation ignores this flag, the module
emulates it (I will appreciate receiving feedback about the
interoperation of this module with other server implementations when
this flag is used).

=item SSH2_FXF_CREAT

If this flag is specified, then a new file will be created if one does
not already exist.

=item SSH2_FXF_TRUNC

Forces an existing file with the same name to be truncated to zero
length when creating a file. C<SSH2_FXF_CREAT> must also be specified
if this flag is used.

=item SSH2_FXF_EXCL

Causes the request to fail if the named file already exists.
C<SSH2_FXF_CREAT> must also be specified if this flag is used.

=back

When creating a new remote file, C<$attrs> allows to set its initial
attributes. C<$attrs> has to be an object of class
L<Net::SFTP::Foreign::Attributes>.

=item $sftp-E<gt>close($handle)

Closes the remote file handle C<$handle>.

Files are automatically closed on the handle C<DESTROY> method when
not done explicitelly.

Returns true on success and undef on failure.

=item $sftp-E<gt>read($handle, $length)

reads C<$length> bytes from an open file handle C<$handle>. On success
returns the data read from the remote file and undef on failure
(including EOF).

=item $sftp-E<gt>write($handle, $data)

writes C<$data> to the remote file C<$handle>. Returns the number of
bytes written or undef on failure.

=item $sftp-E<gt>readline($handle)

=item $sftp-E<gt>readline($handle, $sep)

in scalar context reads and returns the next line from the remote
file. In list context, it returns all the lines from the current
position to the end of the file.

By default "\n" is used as the separator between lines, but a
different one can be used passing it as the second method argument. If
the empty string is used, it returns all the data from the current
position to the end of the file as one line.

=item $sftp-E<gt>getc($handle)

returns the next character from the file.

=item $sftp-E<gt>seek($handle, $pos, $whence)

sets the current position for the remote file handle C<$handle>. If
C<$whence> is 0, the position is set relative to the beginning of the
file; if C<$whence> is 1, position is relative to current position and
if $<$whence> is 2, position is relative to the end of the file.

returns a trues value on success, undef on failure.

=item $sftp-E<gt>tell($fh)

returns the current position for the remote file handle C<$handle>.

=item $sftp-E<gt>eof($fh)

reports whether the remote file handler points at the end of the file.

=item $sftp-E<gt>flush($fh)

X<flush>writes to the remote file any pending data and discards the read
cache.

=item $sftp-E<gt>sftpread($handle, $offset, $length)

low level method that sends a SSH2_FXP_READ request to read from an
open file handle C<$handle>, C<$length> bytes starting at C<$offset>.

Returns the data read on success and undef on failure.

Some servers (for instance OpenSSH SFTP server) limit the size of the
read requests and so the length of data returned can be smaller than
requested.

=item $sftp-E<gt>sftpwrite($handle, $offset, $data)

low level method that sends a C<SSH_FXP_WRITE> request to write to an
open file handle C<$handle>, starting at C<$offset>, and where the
data to be written is in C<$data>.

Returns true on success and undef on failure.

=item $sftp-E<gt>opendir($path)

Sends a C<SSH_FXP_OPENDIR> command to open the remote directory
C<$path>, and returns an open handle on success (unfortunately,
current versions of perl does not support directory operations via
tied handles, so it is not possible to use the returned handle as a
native one).

On failure returns C<undef>.

=item $sftp-E<gt>closedir($handle)

closes the remote directory handle C<$handle>.

Directory handles are closed from their C<DESTROY> method when not
done explicitly.

Return true on success, undef on failure.

=item $sftp-E<gt>readdir($handle)

returns the next entry from the remote directory C<$handle> (or all
the remaining entries when called in list context).

The return values are a hash with three keys: C<filename>, C<longname> and
C<a>. The C<a> value contains a L<Net::SFTP::Foreign::Attributes>
object describing the entry.

Returns undef on error or when no more entries exist on the directory.

=item $sftp-E<gt>stat($path)

performs a C<stat> on the remote file C<$path> and returns a
L<Net::SFTP::Foreign::Attributes> object with the result values.

Returns undef on failure.

=item $sftp-E<gt>fstat($handle)

is similar to the previous method but its argument has to be a handle
to an already open remote file instead of a file name.

=item $sftp-E<gt>lstat($path)

is similar to C<stat> method but stats a symbolic link instead of the
file the symbolic links points to.

=item $sftp-E<gt>setstat($path, $attrs)

sets file attributes on remote file C<$path>.

Returns true on success and undef on failure.

=item $sftp-E<gt>fsetstat($handle, $attrs)

is similar to setstat but its first argument has to be an open remote
file handle instead of a file name.

=item $sftp-E<gt>remove($path)

Sends a C<SSH_FXP_REMOVE> command to remove the remote file
C<$path>. Returns a true value on success and undef on failure.

=item $sftp-E<gt>mkdir($path)

=item $sftp-E<gt>mkdir($path, $attrs)

Sends a C<SSH_FXP_MKDIR> command to create a remote directory C<$path>
whose attributes are initialized to C<$attrs> (a
L<Net::SFTP::Foreign::Attributes> object) if given.

Returns a true value on success and undef on failure.

=item $sftp-E<gt>mkpath($path)

=item $sftp-E<gt>mkpath($path, $attrs)

This method is similar to C<mkdir> but also creates any non-existant
parent directories recursively.

=item $sftp-E<gt>rmdir($path)

Sends a C<SSH_FXP_RMDIR> command to remove a remote directory
C<$path>. Returns a true value on success and undef on failure.

=item $sftp-E<gt>realpath($path)

Sends a C<SSH_FXP_REALPATH> command to canonicalise C<$path>
to an absolute path. This can be useful for turning paths
containing C<'..'> into absolute paths.

Returns the absolute path on success, C<undef> on failure.

=item $sftp-E<gt>rename($old, $new, %opts)

Sends a C<SSH_FXP_RENAME> command to rename C<$old> to C<$new>.
Returns a true value on success and undef on failure.

Accepted options are:

=over 4

=item overwrite => $bool

By default, the rename operation fails when a file C<$new> already
exists. When this options is set, any previous existant file is
deleted first (the C<atomic_rename> operation will be used if
available).

Note than under some conditions the target file could be deleted and
afterwards the rename operation fail.

=back

=item $sftp-E<gt>atomic_rename($old, $new)

Renames a file using the C<posix-rename@openssh.com> extension when
available.

Unlike the C<rename> method, it overwrites any previous C<$new> file.

=item $sftp-E<gt>readlink($path)

Sends a C<SSH_FXP_READLINK> command to read the path where the
simbolic link is pointing.

Returns the target path on success and undef on failure.

=item $sftp-E<gt>symlink($sl, $target)

Sends a C<SSH_FXP_SYMLINK> command to create a new symbolic link
C<$sl> pointing to C<$target>.

C<$target> is stored as-is, without any path expansion taken place on
it. Use C<realpath> to normalize it:

  $sftp->symlink("foo.lnk" => $sftp->realpath("../bar"))

=item $sftp-E<gt>hardlink($hl, $target)

Creates a hardlink on the server.

This command requires support for the 'hardlink@openssh.com' extension
on the server (available in OpenSSH from version 5.7).

=item $sftp-E<gt>statvfs($path)

=item $sftp-E<gt>fstatvfs($fh)

On servers supporting C<statvfs@openssh.com> and
C<fstatvfs@openssh.com> extensions respectively, these methods return
a hash reference with information about the file system where the file
named C<$path> or the open file C<$fh> resides.

The hash entries are:

  bsize   => file system block size
  frsize  => fundamental fs block size
  blocks  => number of blocks (unit f_frsize)
  bfree   => free blocks in file system
  bavail  => free blocks for non-root
  files   => total file inodes
  ffree   => free file inodes
  favail  => free file inodes for to non-root
  fsid    => file system id
  flag    => bit mask of f_flag values
  namemax => maximum filename length

The values of the f_flag bit mask are as follows:

  SSH2_FXE_STATVFS_ST_RDONLY => read-only
  SSH2_FXE_STATVFS_ST_NOSUID => no setuid

=item $sftp-E<gt>disconnect

Closes the SSH connection to the remote host. From this point the
object becomes mostly useless.

Usually, this method should not be called explicitly, but implicitly
from the DESTROY method when the object goes out of scope.

See also the documentation for the C<autodiscconnect> constructor
argument.

=item $sftp-E<gt>autodisconnect($ad)

Sets the C<autodisconnect> behaviour.

See also the documentation for the C<autodiscconnect> constructor
argument. The values accepted here are the same as there.

=back


=head2 On the fly data conversion

Some of the methods on this module allow to perform on the fly data
conversion via the C<conversion> option that accepts the following
values:

=over 4

=item conversion =E<gt> 'dos2unix'

Converts CR+LF line endings (as commonly used under MS-DOS) to LF
(Unix).

=item conversion =E<gt> 'unix2dos'

Converts LF line endings (Unix) to CR+LF (DOS).

=item conversion =E<gt> sub { CONVERT $_[0] }

When a callback is given, it is invoked repeatly as chunks of data
become available. It has to change C<$_[0]> in place in order to
perform the conversion.

Also, the subroutine is called one last time with and empty data
string to indicate that the transfer has finished, so that
intermediate buffers can be flushed.

Note that when writing conversion subroutines, special care has to be
taken to handle sequences crossing chunk borders.

=back

The data conversion is always performed before any other callback
subroutine is called.

See the Wikipedia entry on line endings
L<http://en.wikipedia.org/wiki/Newline> or the article Understanding
Newlines by Xavier Noria
(L<http://www.onlamp.com/pub/a/onlamp/2006/08/17/understanding-newlines.html>)
for details about the different conventions.

=head1 FAQ

=over 4

=item Closing the connection:

B<Q>: How do I close the connection to the remote server?

B<A>: let the C<$sftp> object go out of scope or just undefine it:

  undef $sftp;

=item Using Net::SFTP::Foreign from a cron script:

B<Q>: I wrote a script for performing sftp file transfers that works
beautifully from the command line. However when I try to run the same
script from cron it fails with a broken pipe error:

  open2: exec of ssh -l user some.location.com -s sftp
    failed at Net/SFTP/Foreign.pm line 67

B<A>: C<ssh> is not on your cron PATH.

The remedy is either to add the location of the C<ssh> application to
your cron PATH or to use the C<ssh_cmd> option of the C<new> method to
hardcode the location of C<ssh> inside your script, for instance:

  my $ssh = Net::SFTP::Foreign->new($host,
                                    ssh_cmd => '/usr/local/ssh/bin/ssh');

=item C<more> constructor option expects an array reference:

B<Q>: I'm trying to pass in the private key file using the -i option,
but it keep saying it couldn't find the key. What I'm doing wrong?

B<A>: The C<more> argument on the constructor expects a single option
or a reference to an array of options. It will not split an string
containing several options.

Arguments to SSH options have to be also passed as different entries
on the array:

  my $sftp = Net::SFTP::Foreign->new($host,
                                      more => [qw(-i /home/foo/.ssh/id_dsa)]);

Note also that latest versions of Net::SFTP::Foreign support the
C<key_path> argument:

  my $sftp = Net::SFTP::Foreign->new($host,
                                      key_path => '/home/foo/.ssh/id_dsa');

=item Plink and password authentication

B<Q>: Why password authentication is not supported for the plink SSH
client?

B<A>: A bug in plink breaks it.

Newer versions of Net::SFTP::Foreign pass the password to C<plink>
using its C<-pw> option. As this feature is not completely secure a
warning is generated.

It can be silenced (though, don't do it without understanding why it
is there, please!) as follows:

  no warnings 'Net::SFTP::Foreign';
  my $sftp = Net::SFTP::Foreign->new('foo@bar',
                                     ssh_cmd => 'plink',
                                     password => $password);
  $sftp->die_on_error;

=item Plink

B<Q>: What is C<plink>?

B<A>: Plink is a command line tool distributed with the
L<PuTTY|http://the.earth.li/~sgtatham/putty/> SSH client. Very popular
between MS Windows users, it is also available for Linux and other
Unixes now.

=item Put method fails

B<Q>: put fails with the following error:

  Couldn't setstat remote file (fsetstat): The requested operation
  cannot be performed because there is a file transfer in progress.

B<A>: Try passing the C<late_set_perm> option to the put method:

  $sftp->put($local, $remote, late_set_perm => 1)
     or die "unable to transfer file: " . $sftp->error;

Some servers do not support the C<fsetstat> method on open file
handles. Setting this flag allows to delay that operation until the
file has been completely transferred and the remote file handle
closed.

Send me a bug report containing a dump of your $sftp object so I
can add code for your particular server software to activate the
work-around automatically.

=item Put method fails even with late_set_perm set

B<Q>: I added C<late_set_perm =E<gt> 1> to the put call, but we are still
receiving the error "Couldn't setstat remote file (setstat)".

B<A>: Some servers forbid the SFTP C<setstat> operation used by the
C<put> method for replicating the file permissions and timestamps on
the remote side.

As a work around you can just disable the feature:

  $sftp->put($local_file, $remote_file,
             copy_perms => 0, copy_time => 0);

=item Disable password authentication completely

B<Q>: When we try to open a session and the key either doesn't exist
or is invalid, the child SSH hangs waiting for a password to be
entered.  Is there a way to make this fail back to the Perl program to
be handled?

B<A>: Disable anything but public key SSH authentication calling the
new method as follows:

  $sftp = Net::SFTP::Foreign->new($host,
                more => [qw(-o PreferredAuthentications=publickey)])

See L<ssh_config(5)> for the details.

=item Understanding C<$attr-E<gt>perm> bits

B<Q>: How can I know if a directory entry is a (directory|link|file|...)?

B<A>: Use the C<S_IS*> functions from L<Fcntl>. For instance:

  use Fcntl qw(S_ISDIR);
  my $ls = $sftp->ls or die $sftp->error;
  for my $entry (@$ls) {
    if (S_ISDIR($entry->{a}->perm)) {
      print "$entry->{filename} is a directory\n";
    }
  }

=item Host key checking

B<Q>: Connecting to a remote server with password authentication fails
with the following error:

  The authenticity of the target host can not be established,
  connect from the command line first

B<A>: That probably means that the public key from the remote server
is not stored in the C<~/.ssh/known_hosts> file. Run an SSH Connection
from the command line as the same user as the script and answer C<yes>
when asked to confirm the key supplied.

Example:

  $ ssh pluto /bin/true
  The authenticity of host 'pluto (172.25.1.4)' can't be established.
  RSA key fingerprint is 41:b1:a7:86:d2:a9:7b:b0:7f:a1:00:b7:26:51:76:52.
  Are you sure you want to continue connecting (yes/no)? yes

Your SSH client may also support some flag to disable this check, but
doing it can ruin the security of the SSH protocol so I advise against
its usage.

Example:

  # Warning: don't do that unless you fully understand
  # its security implications!!!
  $sftp = Net::SFTP::Foreign->new($host,
                                  more => [-o => 'StrictHostKeyChecking no'],
                                  ...);

=back

=head1 BUGS

These are the currently known bugs:

=over 4

=item - Doesn't work on VMS:

The problem is related to L<IPC::Open3> not working on VMS. Patches
are welcome!

=item - Dirty cleanup:

On some operating systems, closing the pipes used to comunicate with
the slave SSH process does not terminate it and a work around has to
be applied. If you find that your scripts hung when the $sftp object
gets out of scope, try setting C<$Net::SFTP::Foreign::dirty_cleanup>
to a true value and also send me a report including the value of
C<$^O> on your machine and the OpenSSH version.

From version 0.90_18 upwards, a dirty cleanup is performed anyway when
the SSH process does not terminate by itself in 8 seconds or less.

=item - Reversed symlink arguments:

This package uses the non-conforming OpenSSH argument order for the
SSH_FXP_SYMLINK command that seems to be the de facto standard. When
interacting with SFTP servers that follow the SFTP specification, the
C<symlink> method will interpret its arguments in reverse order.

=item - IPC::Open3 bugs on Windows

On Windows the IPC::Open3 module is used to spawn the slave SSH
process. That module has several nasty bugs (related to STDIN, STDOUT
and STDERR being closed or not being assigned to file descriptors 0, 1
and 2 respectively) that will cause the connection to fail.

Specifically this is known to happen under mod_perl/mod_perl2.

=back

Also, the following features should be considered experimental:

- support for Tectia server

- numbered feature

- autodie mode

=head1 SUPPORT

To report bugs, send me and email or use the CPAN bug tracking system
at L<http://rt.cpan.org>.

=head2 Commercial support

Commercial support, professional services and custom software
development around this module are available through my current
company. Drop me an email with a rough description of your
requirements and we will get back to you ASAP.

=head2 My wishlist

If you like this module and you're feeling generous, take a look at my
Amazon Wish List: L<http://amzn.com/w/1WU1P6IR5QZ42>

Also consider contributing to the OpenSSH project this module builds
upon: L<http://www.openssh.org/donations.html>.

=head1 SEE ALSO

Information about the constants used on this module is available from
L<Net::SFTP::Foreign::Constants>. Information about attribute objects
is available from L<Net::SFTP::Foreign::Attributes>.

General information about SSH and the OpenSSH implementation is
available from the OpenSSH web site at L<http://www.openssh.org/> and
from the L<sftp(1)> and L<sftp-server(8)> manual pages.

Net::SFTP::Foreign integrates nicely with my other module
L<Net::OpenSSH>.

L<Net::SFTP::Foreign::Backend::Net_SSH2> allows to run
Net::SFTP::Foreign on top of L<Net::SSH2> (nowadays, this combination
is probably the best option under Windows).

Modules offering similar functionality available from CPAN are
L<Net::SFTP> and L<Net::SSH2>.

L<Test::SFTP> allows to run tests against a remote SFTP server.

L<autodie>.

=head1 COPYRIGHT

Copyright (c) 2005-2011 Salvador FandiE<ntilde>o (sfandino@yahoo.com).

Copyright (c) 2001 Benjamin Trott, Copyright (c) 2003 David Rolsky.

_glob_to_regex method based on code (c) 2002 Richard Clamp.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the LICENSE file included
with this module.

=cut
SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign";
    open(FILE, ">$dir/Net/SFTP/Foreign/Attributes.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Attributes;

our $VERSION = '1.68_05';

use strict;
use warnings;
use Carp;

use Net::SFTP::Foreign::Constants qw( :att );
use Net::SFTP::Foreign::Buffer;

sub new {
    my $class = shift;
    return bless { flags => 0}, $class;
}

sub new_from_stat {
    if (@_ > 1) {
	my ($class, undef, undef, $mode, undef,
	    $uid, $gid, undef, $size, $atime, $mtime) = @_;
	my $self = $class->new;

	$self->set_perm($mode);
	$self->set_ugid($uid, $gid);
	$self->set_size($size);
	$self->set_amtime($atime, $mtime);
	return $self;
    }
    return undef;
}

sub new_from_buffer {
    my ($class, $buf) = @_;
    my $self = $class->new;
    my $flags = $self->{flags} = $buf->get_int32_untaint;

    if ($flags & SSH2_FILEXFER_ATTR_SIZE) {
	$self->{size} = $buf->get_int64_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_UIDGID) {
	$self->{uid} = $buf->get_int32_untaint;
	$self->{gid} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
	$self->{perm} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
	$self->{atime} = $buf->get_int32_untaint;
	$self->{mtime} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_EXTENDED) {
        my $n = $buf->get_int32;
	$n >= 0 and $n <= 10000 or return undef;
        my @pairs = map $buf->get_str, 1..2*$n;
        $self->{extended} = \@pairs;
    }

    $self;
}

sub skip_from_buffer {
    my ($class, $buf) = @_;
    my $flags = $buf->get_int32;
    if ($flags == ( SSH2_FILEXFER_ATTR_SIZE |
		    SSH2_FILEXFER_ATTR_UIDGID |
		    SSH2_FILEXFER_ATTR_PERMISSIONS |
		    SSH2_FILEXFER_ATTR_ACMODTIME )) {
	$buf->skip_bytes(28);
    }
    else {
	my $len = 0;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_SIZE;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_UIDGID;
	$len += 4 if $flags & SSH2_FILEXFER_ATTR_PERMISSIONS;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_ACMODTIME;
	$buf->skip_bytes($len);
	if ($flags & SSH2_FILEXFER_ATTR_EXTENDED) {
	    my $n = $buf->get_int32;
	    $buf->skip_str, $buf->skip_str for (1..$n);
	}
    }
}

sub as_buffer {
    my $a = shift;
    my $buf = Net::SFTP::Foreign::Buffer->new(int32 => $a->{flags});

    if ($a->{flags} & SSH2_FILEXFER_ATTR_SIZE) {
        $buf->put_int64(int $a->{size});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_UIDGID) {
        $buf->put(int32 => $a->{uid}, int32 => $a->{gid});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_PERMISSIONS) {
        $buf->put_int32($a->{perm});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_ACMODTIME) {
        $buf->put(int32 => $a->{atime}, int32 => $a->{mtime});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_EXTENDED) {
        my $pairs = $a->{extended};
        $buf->put_int32(int(@$pairs / 2));
        $buf->put_str($_) for @$pairs;
    }

    $buf;
}

sub flags { shift->{flags} }

sub size { shift->{size} }

sub set_size {
    my ($self, $size) = @_;
    if (defined $size) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_SIZE;
	$self->{size} = $size;
    }
    else {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_SIZE;
	delete $self->{size}
    }
}

sub uid { shift->{uid} }

sub gid { shift->{gid} }

sub set_ugid {
    my ($self, $uid, $gid) = @_;
    if (defined $uid and defined $gid) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_UIDGID;
	$self->{uid} = $uid;
	$self->{gid} = $gid;
    }
    elsif (!defined $uid and !defined $gid) {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_UIDGID;
	delete $self->{uid};
	delete $self->{gid};
    }
    else {
	croak "wrong arguments for set_ugid"
    }
}

sub perm { shift->{perm} }

sub set_perm {
    my ($self, $perm) = @_;
    if (defined $perm) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_PERMISSIONS;
	$self->{perm} = $perm;
    }
    else {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_PERMISSIONS;
	delete $self->{perm}
    }
}

sub atime { shift->{atime} }

sub mtime { shift->{mtime} }

sub set_amtime {
    my ($self, $atime, $mtime) = @_;
    if (defined $atime and defined $mtime) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_ACMODTIME;
	$self->{atime} = $atime;
	$self->{mtime} = $mtime;
    }
    elsif (!defined $atime and !defined $mtime) {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_ACMODTIME;
	delete $self->{atime};
	delete $self->{mtime};
    }
    else {
	croak "wrong arguments for set_amtime"
    }
}

sub extended { @{shift->{extended} || [] } }

sub set_extended {
    my $self = shift;
    @_ & 1 and croak "odd number of arguments passed to set_extended";
    if (@_) {
        $self->{flags} |= SSH2_FILEXFER_ATTR_EXTENDED;
        $self->{extended} = [@_];
    }
    else {
        $self->{flags} &= ~SSH2_FILEXFER_ATTR_EXTENDED;
        delete $self->{extended};
    }
}

sub append_extended {
    my $self = shift;
    @_ & 1 and croak "odd number of arguments passed to append_extended";
    my $pairs = $self->{extended};
    if (@$pairs) {
        push @$pairs, @_;
    }
    else {
        $self->set_extended(@_);
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Attributes - File/directory attribute container

=head1 SYNOPSIS

    use Net::SFTP::Foreign;

    my $a1 = Net::SFTP::Foreign::Attributes->new();
    $a1->set_size($size);
    $a1->set_ugid($uid, $gid);

    my $a2 = $sftp->stat($file)
        or die "remote stat command failed: ".$sftp->status;

    my $size = $a2->size;
    my $mtime = $a2->mtime;

=head1 DESCRIPTION

I<Net::SFTP::Foreign::Attributes> encapsulates file/directory
attributes for I<Net::SFTP::Foreign>. It also provides serialization
and deserialization methods to encode/decode attributes into
I<Net::SFTP::Foreign::Buffer> objects.

=head1 USAGE

=over 4

=item Net::SFTP::Foreign::Attributes-E<gt>new()

Returns a new C<Net::SFTP::Foreign::Attributes> object.

=item Net::SFTP::Foreign::Attributes-E<gt>new_from_buffer($buffer)

Creates a new attributes object and populates it with information read
from C<$buffer>.

=item $attrs-E<gt>as_buffer

Serializes the I<Attributes> object I<$attrs> into a buffer object.

=item $attrs-E<gt>flags

returns the value of the flags field.

=item $attrs-E<gt>size

returns the values of the size field or undef if it is not set.

=item $attrs-E<gt>uid

returns the value of the uid field or undef if it is not set.

=item $attrs-E<gt>gid

returns the value of the gid field or undef if it is not set.

=item $attrs-E<gt>perm

returns the value of the permissions field or undef if it is not set.

See also L<perlfunc/stat> for instructions on how to process the
returned value with the L<Fcntl> module.

For instance, the following code checks if some attributes object
corresponds to a directory:

  use Fctnl qw(S_ISDIR);
  ...
  if (S_ISDIR($attr->perm)) {
    # it is a directory!
  }

=item $attrs-E<gt>atime

returns the value of the atime field or undef if it is not set.

=item $attrs-E<gt>mtime

returns the value of the mtime field or undef if it is not set.

=item %extended = $attr-E<gt>extended

returns the vendor-dependent extended attributes

=item $attrs-E<gt>set_size($size)

sets the value of the size field, or if $size is undef removes the
field. The flags field is adjusted accordingly.

=item $attrs-E<gt>set_perm($perm)

sets the value of the permsissions field or removes it if the value is
undefined. The flags field is also adjusted.

=item $attr-E<gt>set_ugid($uid, $gid)

sets the values of the uid and gid fields, or removes them if they are
undefined values. The flags field is adjusted.

This pair of fields can not be set separatelly because they share the
same bit on the flags field and so both have to be set or not.

=item $attr-E<gt>set_amtime($atime, $mtime)

sets the values of the atime and mtime fields or remove them if they
are undefined values. The flags field is also adjusted.

=item $attr-E<gt>set_extended(%extended)

sets the vendor-dependent extended attributes

=item $attr-E<gt>append_extended(%more_extended)

adds more pairs to the list of vendor-dependent extended attributes

=back

=head1 COPYRIGHT

Copyright (c) 2006-2008 Salvador FandiE<ntilde>o.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Buffer.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Buffer;

our $VERSION = '1.68_05';

use strict;
use warnings;
no warnings 'uninitialized';

use Carp;

use constant HAS_QUADS => do {
    local $@;
    local $SIG{__DIE__};
    no warnings;
    eval q{
        pack(Q => 0x1122334455667788) eq "\x11\x22\x33\x44\x55\x66\x77\x88"
    }
};

sub new {
    my $class = shift;
    my $data = '';
    @_ and put(\$data, @_);
    bless \$data, $class;
}

sub make { bless \$_[1], $_[0] }

sub bytes { ${$_[0]} }

sub get_int8 {
    length ${$_[0]} >=1 or return undef;
    unpack(C => substr(${$_[0]}, 0, 1, ''));
}

sub get_int32 {
    length ${$_[0]} >=4 or return undef;
    unpack(N => substr(${$_[0]}, 0, 4, ''));
}

sub get_int32_untaint {
    my ($v) = substr(${$_[0]}, 0, 4, '') =~ /(.*)/s;
    get_int32(\$v);
}

sub get_int64_quads {
    length ${$_[0]} >= 8 or return undef;
    unpack Q => substr(${$_[0]}, 0, 8, '')
}

sub get_int64_no_quads {
    length ${$_[0]} >= 8 or return undef;
    my ($big, $small) = unpack(NN => substr(${$_[0]}, 0, 8, ''));
    if ($big) {
	# too big for an integer, try to handle it as a float:
	my $high = $big * 4294967296;
	my $result = $high + $small;
	unless ($result - $high == $small) {
	    # too big event for a float, use a BigInt;
	    require Math::BigInt;
	    $result = Math::BigInt->new($big);
	    $result <<= 32;
	    $result += $small;
	}
	return $result;
    }
    return $small;
}

*get_int64 = (HAS_QUADS ? \&get_int64_quads : \&get_int64_no_quads);

sub get_int64_untaint {
    my ($v) = substr(${$_[0]}, 0, 8, '') =~ /(.*)/s;
    get_int64(\$v);
}

sub get_str {
    my $self = shift;
    length $$self >=4 or return undef;
    my $len = unpack(N => substr($$self, 0, 4, ''));
    length $$self >=$len or return undef;
    substr($$self, 0, $len, '');
}

sub get_attributes { Net::SFTP::Foreign::Attributes->new_from_buffer($_[0]) }


sub skip_bytes { substr(${$_[0]}, 0, $_[1], '') }

sub skip_str {
    my $self = shift;
    my $len = $self->get_int32;
    substr($$self, 0, $len, '');
}

sub put_int8 { ${$_[0]} .= pack(C => $_[1]) }

sub put_int32 { ${$_[0]} .= pack(N => $_[1]) }

sub put_int64_quads { ${$_[0]} .= pack(Q => $_[1]) }

sub put_int64_no_quads {
    if ($_[1] >= 4294967296) {
	my $high = int ( $_[1] / 4294967296);
	my $low = int ($_[1] - $high * 4294967296);
	${$_[0]} .= pack(NN => $high, $low)
    }
    else {
	${$_[0]} .= pack(NN => 0, $_[1])
    }
}

*put_int64 = (HAS_QUADS ? \&put_int64_quads : \&put_int64_no_quads);

sub put_str {
    utf8::downgrade($_[1]) or croak "UTF8 data reached the SFTP buffer";
    ${$_[0]} .= pack(N => length($_[1])) . $_[1]
}

sub put_char { ${$_[0]} .= $_[1] }

sub _attrs_as_buffer {
    my $attrs = shift;
    my $ref = ref $attrs;
    Net::SFTP::Foreign::Attributes->isa($ref)
	    or croak("Object of class Net::SFTP::Foreign::Attributes "
		     . "expected, $ref found");
    $attrs->as_buffer;
}

sub put_attributes { ${$_[0]} .= ${_attrs_as_buffer $_[1]} }

my %unpack = ( int8 => \&get_int8,
	       int32 => \&get_int32,
	       int64 => \&get_int64,
	       str => \&get_str,
	       attr => \&get_attributtes );

sub get {
    my $buf = shift;
    map { $unpack{$_}->($buf) } @_;
}

my %pack = ( int8 => sub { pack C => $_[0] },
	     int32 => sub { pack N => $_[0] },
	     int64 => sub {
		 if (HAS_QUADS) {
		     return pack(Q => $_[0])
		 }
		 else {
		     if ($_[0] >= 4294967296) {
			 my $high = int ( $_[0] / 4294967296);
			 my $low = int ($_[0] - $high * 4294967296);
			 return pack(NN => $high, $low)
		     }
		     else {
			 return pack(NN => 0, $_[0])
		     }
		 }
	     },
	     str => sub { pack(N => length($_[0])), $_[0] },
	     char => sub { $_[0] },
	     attr => sub { ${_attrs_as_buffer $_[0]} } );

sub put {
    my $buf =shift;
    @_ & 1 and croak "bad number of arguments for put (@_)";
    my @parts;
    while (@_) {
	my $type = shift;
	my $value = shift;
	push @parts, $pack{$type}->($value)
    }
    $$buf.=join('', @parts);
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Buffer - Read/write buffer class

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Buffer;
    my $buffer = Net::SFTP::Foreign::Buffer->new;

=head1 DESCRIPTION

I<Net::SFTP::Foreign::Buffer> provides read/write buffer functionality for
SFTP.

=head1 AUTHOR & COPYRIGHTS

Please see the Net::SFTP::Foreign manpage for author, copyright, and
license information.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Common.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Common;

our $VERSION = '1.68_01';

use strict;
use warnings;
use Carp;

BEGIN {
    # Some versions of Scalar::Util are crippled
    require Scalar::Util;
    eval { Scalar::Util->import(qw(dualvar tainted)); 1 }
        or do {
            *tainted = sub { croak "The version of Scalar::Util installed on your system "
                                 . "does not provide 'tainted'" };
            *dualvar = sub { $_[0] };
        };
}

use Net::SFTP::Foreign::Helpers qw(_gen_wanted _ensure_list _debug _glob_to_regex _is_lnk _is_dir $debug);
use Net::SFTP::Foreign::Constants qw(:status);

my %status_str = ( SSH2_FX_OK, "OK",
		   SSH2_FX_EOF, "End of file",
		   SSH2_FX_NO_SUCH_FILE, "No such file or directory",
		   SSH2_FX_PERMISSION_DENIED, "Permission denied",
		   SSH2_FX_FAILURE, "Failure",
		   SSH2_FX_BAD_MESSAGE, "Bad message",
		   SSH2_FX_NO_CONNECTION, "No connection",
		   SSH2_FX_CONNECTION_LOST, "Connection lost",
		   SSH2_FX_OP_UNSUPPORTED, "Operation unsupported" );

our $debug;

sub _set_status {
    my $sftp = shift;
    my $code = shift;
    if ($code) {
        my $str;
        if (@_) {
            $str = join ': ', @_;
            ($str) = $str =~ /(.*)/
                if (${^TAINT} && tainted $str);
        }
        unless (defined $str and length $str) {
            $str = $status_str{$code} || "Unknown status ($code)";
        }
        $debug and $debug & 64 and _debug("_set_status code: $code, str: $str");
	return $sftp->{_status} = dualvar($code, $str);
    }
    else {
	return $sftp->{_status} = 0;
    }
}

sub status { shift->{_status} }

sub _set_error {
    my $sftp = shift;
    my $code = shift;
    if ($code) {
        my $str;
        if (@_) {
            $str = join ': ', @_;
            ($str) = $str =~ /(.*)/
                if (${^TAINT} && tainted $str);
        }
        else {
	    $str = $code ? "Unknown error $code" : "OK";
	}
        $debug and $debug & 64 and _debug("_set_err code: $code, str: $str");
	my $error = $sftp->{_error} = dualvar $code, $str;
        croak $error if $sftp->{_autodie};
        return $error;
    }
    else {
	return $sftp->{_error} = 0;
    }
}

sub _clear_error_and_status {
    my $sftp = shift;
    $sftp->{_error} = 0;
    $sftp->{_status} = 0;
}

sub _copy_error {
    $_[0]->{_error} = $_[1]->{_error};
}

sub error { shift->{_error} }

sub die_on_error {
    my $sftp = shift;
    $sftp->{_error} and croak(@_ ? "@_: $sftp->{_error}" : $sftp->{_error});
}

sub _ok_or_autodie {
    my $sftp = shift;
    return 1 unless $sftp->{_error};
    $sftp->{_autodie} and croak $sftp->{_error};
    undef;
}

sub _set_errno {
    my $sftp = shift;
    if ($sftp->{_error}) {
	my $status = $sftp->{_status} + 0;
	my $error = $sftp->{_error} + 0;
	if ($status == SSH2_FX_EOF) {
	    return;
	}
        elsif ($status == SSH2_FX_NO_SUCH_FILE) {
	    $! = Errno::ENOENT();
	}
	elsif ($status == SSH2_FX_PERMISSION_DENIED) {
	    $! = Errno::EACCES();
	}
	elsif ($status == SSH2_FX_BAD_MESSAGE) {
	    $! = Errno::EBADMSG();
	}
	elsif ($status == SSH2_FX_OP_UNSUPPORTED) {
	    $! = Errno::ENOTSUP()
	}
	elsif ($status) {
	    $! = Errno::EIO()
	}
    }
}

sub _call_on_error {
    my ($sftp, $on_error, $entry) = @_;
    $on_error and $sftp->error
	and $on_error->($sftp, $entry);
    $sftp->_set_error;
    $sftp->_set_status;
}

# this method code is a little convoluted because we are trying to
# keep in memory as few entries as possible!!!
sub find {
    @_ >= 1 or croak 'Usage: $sftp->find($remote_dirs, %opts)';

    my $self = shift;
    my %opts = @_ & 1 ? ('dirs', @_) : @_;

    $self->_set_error;
    $self->_set_status;

    my $dirs = delete $opts{dirs};
    my $follow_links = delete $opts{follow_links};
    my $on_error = delete $opts{on_error};
    local $self->{_autodie} if $on_error;
    my $realpath = delete $opts{realpath};
    my $ordered = delete $opts{ordered};
    my $names_only = delete $opts{names_only};
    my $atomic_readdir = delete $opts{atomic_readdir};
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );
    my $descend = _gen_wanted( delete $opts{descend},
			       delete $opts{no_descend} );

    %opts and croak "invalid option(s) '".CORE::join("', '", keys %opts)."'";

    $dirs = '.' unless defined $dirs;

    my $wantarray = wantarray;
    my (@res, $res);
    my %done;
    my %rpdone; # used to detect cycles

    my @dirs = _ensure_list $dirs;
    my @queue = map { { filename => $_ } } ($ordered ? sort @dirs : @dirs);

    # we use a clousure instead of an auxiliary method to have access
    # to the state:

    my $task = sub {
	my $entry = shift;
	my $fn = $entry->{filename};
	for (1) {
	    my $follow = ($follow_links and _is_lnk($entry->{a}->perm));

	    if ($follow or $realpath) {
		unless (defined $entry->{realpath}) {
                    my $rp = $entry->{realpath} = $self->realpath($fn);
                    next unless (defined $rp and not $rpdone{$rp}++);
		}
	    }

	    if ($follow) {
                my $a = $self->stat($fn);
                if (defined $a) {
                    $entry->{a} = $a;
                    # we queue it for reprocessing as it could be a directory
                    unshift @queue, $entry;
                }
		next;
	    }

	    if (!$wanted or $wanted->($self, $entry)) {
		if ($wantarray) {
                    push @res, ( $names_only
                                 ? ( exists $entry->{realpath}
                                     ? $entry->{realpath}
                                     : $entry->{filename} )
                                 : $entry )
		}
		else {
		    $res++;
		}
	    }
	}
	continue {
	    $self->_call_on_error($on_error, $entry)
	}
    };

    my $try;
    while (@queue) {
	no warnings 'uninitialized';
	$try = shift @queue;
	my $fn = $try->{filename};

	my $a = $try->{a} ||= $self->lstat($fn)
	    or next;

	next if (_is_dir($a->perm) and $done{$fn}++);

	$task->($try);

	if (_is_dir($a->perm)) {
	    if (!$descend or $descend->($self, $try)) {
		if ($ordered or $atomic_readdir) {
		    my $ls = $self->ls( $fn,
					ordered => $ordered,
					_wanted => sub {
					    my $child = $_[1]->{filename};
					    if ($child !~ /^\.\.?$/) {
						$_[1]->{filename} = $self->join($fn, $child);
						return 1;
					    }
					    undef;
					})
			or next;
		    unshift @queue, @$ls;
		}
		else {
		    $self->ls( $fn,
			       _wanted => sub {
				   my $entry = $_[1];
				   my $child = $entry->{filename};
				   if ($child !~ /^\.\.?$/) {
				       $entry->{filename} = $self->join($fn, $child);

				       if (_is_dir($entry->{a}->perm)) {
					   push @queue, $entry;
				       }
				       else {
					   $task->($entry);
				       }
				   }
				   undef } )
			or next;
		}
	    }
	}
    }
    continue {
	$self->_call_on_error($on_error, $try)
    }

    return wantarray ? @res : $res;
}


sub glob {
    @_ >= 2 or croak 'Usage: $sftp->glob($pattern, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $glob, %opts) = @_;
    return () if $glob eq '';

    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $follow_links = delete $opts{follow_links};
    my $ignore_case = delete $opts{ignore_case};
    my $names_only = delete $opts{names_only};
    my $realpath = delete $opts{realpath};
    my $ordered = delete $opts{ordered};
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted});
    my $strict_leading_dot = delete $opts{strict_leading_dot};
    $strict_leading_dot = 1 unless defined $strict_leading_dot;

    %opts and _croak_bad_options(keys %opts);

    my $wantarray = wantarray;

    my (@parts, $top);
    if (ref $glob eq 'Regexp') {
        @parts = ($glob);
        $top = '.';
    }
    else {
        @parts = ($glob =~ m{\G/*([^/]+)}g);
        push @parts, '.' unless @parts;
        $top = ( $glob =~ m|^/|  ? '/' : '.');
    }
    my @res = ( {filename => $top} );
    my $res = 0;

    while (@parts and @res) {
	my @parents = @res;
	@res = ();
	my $part = shift @parts;
        my ($re, $has_wildcards);
        if (ref $part eq 'Regexp') {
            $re = $part;
            $has_wildcards = 1;
        }
	else {
            ($re, $has_wildcards) = _glob_to_regex($part, $strict_leading_dot, $ignore_case);
        }

	for my $parent (@parents) {
	    my $pfn = $parent->{filename};
            if ($has_wildcards) {
                $sftp->ls( $pfn,
                           ordered => $ordered,
                           _wanted => sub {
                               my $e = $_[1];
                               if ($e->{filename} =~ $re) {
                                   my $fn = $e->{filename} = $sftp->join($pfn, $e->{filename});
                                   if ( (@parts or $follow_links)
                                        and _is_lnk($e->{a}->perm) ) {
                                       if (my $a = $sftp->stat($fn)) {
                                           $e->{a} = $a;
                                       }
                                       else {
                                           $sftp->_call_on_error($on_error, $e);
                                           return undef;
                                       }
                                   }
                                   if (@parts) {
                                       push @res, $e if _is_dir($e->{a}->perm)
                                   }
                                   elsif (!$wanted or $wanted->($sftp, $e)) {
                                       if ($wantarray) {
                                           if ($realpath) {
                                               my $rp = $e->{realpath} = $sftp->realpath($e->{filename});
                                               unless (defined $rp) {
                                                   $sftp->_call_on_error($on_error, $e);
                                                   return undef;
                                               }
                                           }
                                           push @res, ($names_only
                                                       ? ($realpath ? $e->{realpath} : $e->{filename} )
                                                       : $e);
                                       }
                                       $res++;
                                   }
                               }
                               return undef
                           } )
                    or $sftp->_call_on_error($on_error, $parent);
            }
            else {
                my $fn = $sftp->join($pfn, $part);
                my $method = ((@parts or $follow_links) ? 'stat' : 'lstat');
                if (my $a = $sftp->$method($fn)) {
                    my $e = { filename => $fn, a => $a };
                    if (@parts) {
                        push @res, $e if _is_dir($a->{perm})
                    }
                    elsif (!$wanted or $wanted->($sftp, $e)) {
                        if ($wantarray) {
                            if ($realpath) {
                                my $rp = $fn = $e->{realpath} = $sftp->realpath($fn);
                                unless (defined $rp) {
                                    $sftp->_call_on_error($on_error, $e);
                                    next;
                                }
                            }
                            push @res, ($names_only ? $fn : $e)
                        }
                        $res++;
                    }
                }
            }
        }
    }
    return wantarray ? @res : $res;
}

sub test_d {
    my ($sftp, $name) = @_;
    my $a = $sftp->stat($name);
    $a ? _is_dir($a->perm) : undef;
}

sub test_e {
    my ($sftp, $name) = @_;
    local ($sftp->{_error}, $sftp->{_status}, $sftp->{_autodie});
    !!$sftp->stat($name)
}

1;

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Compat.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Compat;

our $VERSION = '1.68_04';

use warnings;
use strict;
use Carp;

require Net::SFTP::Foreign;
require Net::SFTP::Foreign::Constants;
require Net::SFTP::Foreign::Attributes::Compat;

our @ISA = qw(Net::SFTP::Foreign);

my $supplant;

sub import {
    for my $arg (@_[1..$#_]) {
	if ($arg eq ':supplant') {
            # print STDERR "suplanting Net::SFTP...\n";
	    if (!$supplant) {
		$supplant = 1;

		@Net::SFTP::ISA = qw(Net::SFTP::Foreign::Compat);
		@Net::SFTP::Attributes::ISA = qw(Net::SFTP::Foreign::Attributes::Compat);
		@Net::SFTP::Constant::ISA = qw(Net::SFTP::Foreign::Constants);

		$INC{q(Net/SFTP.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};
		$INC{q(Net/SFTP/Attributes.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};
		$INC{q(Net/SFTP/Constants.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};

	    }
	}
	else {
	    croak "invalid import tag '$arg'"
	}
    }
}

our %DEFAULTS = ( put => [],
                  get => [],
                  ls  => [],
                  new => [] );

BEGIN {
    my @forbidden = qw( setcwd cwd open opendir sftpread sftpwrite seek
                        tell eof write flush read getc lstat stat fstat
                        remove rmdir mkdir setstat fsetstat close closedir
                        readdir realpath readlink rename symlink abort
                        get_content join glob rremove rget rput error );

    for my $method (@forbidden) {
        my $super = "SUPER::$method";
        no strict 'refs';
        *{$method} = sub {
            unless (index((caller)[0], "Net::SFTP::Foreign") == 0) {
                croak "Method '$method' is not available from " . __PACKAGE__
                    . ", use the real Net::SFTP::Foreign if you want it!";
            }
            shift->$super(@_);
        };
    }
}

sub new {
    my ($class, $host, %opts) = @_;

    my $warn;
    if (exists $opts{warn}) {
	$warn = delete($opts{warn}) || sub {};
    }
    else {
	$warn = sub { warn(CORE::join '', @_, "\n") };
    }

    my $sftp = $class->SUPER::new($host, @{$DEFAULTS{new}}, %opts);

    $sftp->{_compat_warn} = $warn;

    return $sftp;

}

sub _warn {
    my $sftp = shift;
    if (my $w = $sftp->{_compat_warn}) {
	$w->(@_);
    }
}

sub _warn_error {
    my $sftp = shift;
    if (my $e = $sftp->SUPER::error) {
	$sftp->_warn($e);
    }
}

sub status {
    my $status = shift->SUPER::status;
    return wantarray ? ($status + 0, "$status") : $status + 0;
}

sub get {
    my ($sftp, $remote, $local, $cb) = @_;

    my $save = defined(wantarray);
    my @content;

    $sftp->SUPER::get($remote, $local,
                      @{$DEFAULTS{get}},
		      dont_save => !defined($local),
		      callback => sub {
			  my ($sftp, $data, $off, $size) = @_;
			  $cb->($sftp, $data, $off, $size) if $cb;
			  push @content, $data if $save
		      } )
	or return undef;

    if ($save) {
	return CORE::join('', @content);
    }
}

sub put {
    my ($sftp, $local, $remote, $cb) = @_;

    $sftp->SUPER::put($local, $remote,
                      @{$DEFAULTS{put}},
		      (defined $cb ? (callback => $cb) : ()));
    $sftp->_warn_error;
    !$sftp->SUPER::error;
}

sub ls {
    my ($sftp, $path, $cb) = @_;
    if ($cb) {
	$sftp->SUPER::ls($path,
                         @{$DEFAULTS{ls}},
			 wanted => sub { _rebless_attrs($_[1]->{a});
					 $cb->($_[1]);
					 0 } );
	return ();
    }
    else {
	if (my $ls = $sftp->SUPER::ls($path, @{$DEFAULTS{ls}})) {
	    _rebless_attrs($_->{a}) for @$ls;
	    return @$ls;
	}
	return ()
    }
}

sub do_open { shift->SUPER::open(@_) }

sub do_opendir { shift->SUPER::opendir(@_) }

sub do_realpath { shift->SUPER::realpath(@_) }

sub do_read {
    my $sftp = shift;
    my $read = $sftp->SUPER::sftpread(@_);
    $sftp->_warn_error;
    if (wantarray) {
	return ($read, $sftp->status);
    }
    else {
	return $read
    }
}

sub _gen_do_and_status {
    my $method = "SUPER::" . shift;
    return sub {
	my $sftp = shift;
	$sftp->$method(@_);
	$sftp->_warn_error;
	$sftp->status;
    }
}

*do_write = _gen_do_and_status('sftpwrite');
*do_close = _gen_do_and_status('close');
*do_setstat = _gen_do_and_status('setstat');
*do_fsetstat = _gen_do_and_status('fsetstat');
*do_remove = _gen_do_and_status('remove');
*do_rename = _gen_do_and_status('rename');
*do_mkdir = _gen_do_and_status('mkdir');
*do_rmdir = _gen_do_and_status('rmdir');

sub _rebless_attrs {
    my $a = shift;
    if ($a) {
	bless $a,  ( $supplant
		     ? "Net::SFTP::Attributes"
		     : "Net::SFTP::Foreign::Attributes::Compat" );
    }
    $a;
}

sub _gen_do_stat {
    my $method = "SUPER::" . shift;
    return sub {
	my $sftp = shift;
	if (my $a = $sftp->$method(@_)) {
	    return _rebless_attrs($a);
	}
	else {
	    $sftp->_warn_error;
	    return undef;
	}
    }
}

*do_lstat = _gen_do_stat('lstat');
*do_fstat = _gen_do_stat('fstat');
*do_stat = _gen_do_stat('stat');


1;

__END__

=head1 NAME

Net::SFTP::Foreign::Compat - Adaptor for Net::SFTP compatibility

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Compat;
    my $sftp = Net::SFTP::Foreign::Compat->new($host);
    $sftp->get("foo", "bar");
    $sftp->put("bar", "baz");

    use Net::SFTP::Foreign::Compat ':supplant';
    my $sftp = Net::SFTP->new($host);

=head1 DESCRIPTION

This package is a wrapper around L<Net::SFTP::Foreign> that provides
an API (mostly) compatible with that of L<Net::SFTP>.

Methods on this package are identical to those in L<Net::SFTP> except
that L<Net::SFTP::Foreign::Attributes::Compat> objects have to be used
instead of L<Net::SFTP::Attributes>.

If the C<:supplant> tag is used, this module installs also wrappers on
the C<Net::SFTP> and L<Net::SFTP::Attributes> packages so no other
parts of the program have to modified in order to move from Net::SFTP
to Net::SFTP::Foreign.

=head2 Setting defaults

The hash C<%Net::SFTP::Foreign::DEFAULTS> can be used to set default
values for L<Net::SFTP::Foreign> methods called under the hood and
otherwise not accesible through the Net::SFTP API.

The entries currently supported are:

=over

=item new => \@opts

extra options passed to Net::SFTP::Foreign constructor.

=item get => \@opts

extra options passed to Net::SFTP::Foreign::get method.

=item put => \@opts

extra options passed to Net::SFTP::Foreign::put method.

=item ls  => \@opts

extra options passed to Net::SFTP::Foreign::ls method.

=back

=head1 COPYRIGHT

Copyright (c) 2006-2008, 2011 Salvador FandiE<ntilde>o

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Constants.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Constants;

our $VERSION = '1.63_05';

use strict;
use warnings;

use Carp;

require Exporter;
our @ISA = qw(Exporter);
our (@EXPORT_OK, %EXPORT_TAGS);

BEGIN {
    my %constants = ( SSH2_FXP_INIT => 1,
		      SSH2_FXP_VERSION => 2,
		      SSH2_FXP_OPEN => 3,
		      SSH2_FXP_CLOSE => 4,
		      SSH2_FXP_READ => 5,
		      SSH2_FXP_WRITE => 6,
		      SSH2_FXP_LSTAT => 7,
		      SSH2_FXP_FSTAT => 8,
		      SSH2_FXP_SETSTAT => 9,
		      SSH2_FXP_FSETSTAT => 10,
		      SSH2_FXP_OPENDIR => 11,
		      SSH2_FXP_READDIR => 12,
		      SSH2_FXP_REMOVE => 13,
		      SSH2_FXP_MKDIR => 14,
		      SSH2_FXP_RMDIR => 15,
		      SSH2_FXP_REALPATH => 16,
		      SSH2_FXP_STAT => 17,
		      SSH2_FXP_RENAME => 18,
		      SSH2_FXP_READLINK => 19,
		      SSH2_FXP_SYMLINK => 20,
		      SSH2_FXP_STATUS => 101,
		      SSH2_FXP_HANDLE => 102,
		      SSH2_FXP_DATA => 103,
		      SSH2_FXP_NAME => 104,
		      SSH2_FXP_ATTRS => 105,
                      SSH2_FXP_EXTENDED => 200,
                      SSH2_FXP_EXTENDED_REPLY => 201,

		      SSH2_FXF_READ => 0x01,
		      SSH2_FXF_WRITE => 0x02,
		      SSH2_FXF_APPEND => 0x04,
		      SSH2_FXF_CREAT => 0x08,
		      SSH2_FXF_TRUNC => 0x10,
		      SSH2_FXF_EXCL => 0x20,

		      SSH2_FX_OK => 0,
		      SSH2_FX_EOF => 1,
		      SSH2_FX_NO_SUCH_FILE => 2,
		      SSH2_FX_PERMISSION_DENIED => 3,
		      SSH2_FX_FAILURE => 4,
		      SSH2_FX_BAD_MESSAGE => 5,
		      SSH2_FX_NO_CONNECTION => 6,
		      SSH2_FX_CONNECTION_LOST => 7,
		      SSH2_FX_OP_UNSUPPORTED => 8,

		      SSH2_FILEXFER_ATTR_SIZE => 0x01,
		      SSH2_FILEXFER_ATTR_UIDGID => 0x02,
		      SSH2_FILEXFER_ATTR_PERMISSIONS => 0x04,
		      SSH2_FILEXFER_ATTR_ACMODTIME => 0x08,
		      SSH2_FILEXFER_ATTR_EXTENDED => 0x80000000,

		      SSH2_FILEXFER_VERSION => 3,

                      SSH2_FXE_STATVFS_ST_READONLY => 0x1,
                      SSH2_FXE_STATVFS_ST_NOSUID => 0x2,

		      SFTP_ERR_REMOTE_STAT_FAILED => 1,
		      SFTP_ERR_REMOTE_OPEN_FAILED => 2,
		      SFTP_ERR_LOCAL_ALREADY_EXISTS => 3,
		      # SFTP_ERR_LOCAL_OPEN_FAILED => 4,
		      SFTP_ERR_LOCAL_OPEN_FAILED => 26,
		      SFTP_ERR_REMOTE_READ_FAILED => 5,
		      SFTP_ERR_REMOTE_BLOCK_TOO_SMALL => 6,
		      SFTP_ERR_LOCAL_WRITE_FAILED => 7,
		      SFTP_ERR_REMOTE_BAD_PERMISSIONS => 8,
		      SFTP_ERR_LOCAL_CHMOD_FAILED => 9,
		      SFTP_ERR_REMOTE_BAD_TIME => 10,
		      SFTP_ERR_LOCAL_UTIME_FAILED => 11,
		      SFTP_ERR_REMOTE_BAD_MESSAGE => 13,
		      SFTP_ERR_REMOTE_REALPATH_FAILED => 14,
		      SFTP_ERR_REMOTE_OPENDIR_FAILED => 15,
		      SFTP_ERR_REMOTE_WRITE_FAILED => 16,
		      SFTP_ERR_REMOTE_RENAME_FAILED => 17,
		      SFTP_ERR_REMOTE_LSTAT_FAILED => 18,
		      SFTP_ERR_REMOTE_FSTAT_FAILED => 19,
		      SFTP_ERR_REMOTE_CLOSE_FAILED => 20,
		      SFTP_ERR_REMOTE_REMOVE_FAILED => 21,
		      SFTP_ERR_REMOTE_MKDIR_FAILED => 22,
		      SFTP_ERR_REMOTE_RMDIR_FAILED => 23,
		      SFTP_ERR_REMOTE_SETSTAT_FAILED => 24,
		      SFTP_ERR_REMOTE_FSETSTAT_FAILED => 25,
		      SFTP_ERR_LOCAL_STAT_FAILED => 27,
		      SFTP_ERR_LOCAL_READ_ERROR => 28,
		      SFTP_ERR_REMOTE_READDIR_FAILED => 29,
		      SFTP_ERR_REMOTE_READLINK_FAILED => 30,
		      SFTP_ERR_REMOTE_SYMLINK_FAILED => 31,
		      SFTP_ERR_REMOTE_BAD_PATH => 32,
		      SFTP_ERR_LOCAL_MKDIR_FAILED => 33,
		      SFTP_ERR_LOCAL_SYMLINK_FAILED => 34,
		      SFTP_ERR_REMOTE_BAD_OBJECT => 35,
		      SFTP_ERR_REMOTE_ACCESING_CLOSED_FILE => 36,
		      SFTP_ERR_CONNECTION_BROKEN => 37,
		      SFTP_ERR_LOCAL_GENERIC_ERROR => 38,
		      SFTP_ERR_LOCAL_READLINK_FAILED => 39,
		      SFTP_ERR_LOCAL_BAD_PATH => 40,
		      SFTP_ERR_LOCAL_BAD_OBJECT => 41,
		      SFTP_ERR_REMOTE_ALREADY_EXISTS => 42,
                      # SFTP_ERR_BAD_SSH_BINARY => 43,
                      SFTP_ERR_ABORTED => 44,
                      SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL => 45,
                      SFTP_ERR_LOCAL_BIGGER_THAN_REMOTE => 46,
                      SFTP_ERR_LOCAL_SEEK_FAILED => 47,
                      SFTP_ERR_REMOTE_STATVFS_FAILED => 48,
                      SFTP_ERR_REMOTE_FSTATVFS_FAILED => 49,
		      SFTP_ERR_PASSWORD_AUTHENTICATION_FAILED => 50,
                      SFTP_ERR_REMOTE_HARDLINK_FAILED => 51,
		      SFTP_ERR_LOCAL_RENAME_FAILED => 52,
                    );

    for my $key (keys %constants) {
	no strict 'refs';
	my $value = $constants{$key};
        *{$key} = sub () { $value }
    }

    @EXPORT_OK = keys %constants;

    my %etagre = qw( fxp SSH2_FXP_
		     flags SSH2_FXF_
		     att SSH2_FILEXFER_ATTR
		     status SSH2_FX_
		     error SFTP_ERR_
                     ext SSH2_FXE_);

    for my $key (keys %etagre) {
	my $re = qr/^$etagre{$key}/;
	$EXPORT_TAGS{$key} = [grep $_=~$re, @EXPORT_OK];
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Constants - Constant definitions for
Net::SFTP::Foreign

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Constants qw(:tag SSH2_FILEXFER_VERSION);
    print "Protocol version is ", SSH2_FILEXFER_VERSION;

=head1 DESCRIPTION

Net::SFTP::Foreign::Constants provides a list of exportable SFTP
constants: for SFTP messages and commands, for file-open flags,
for status messages, etc. Constants can be exported individually,
or in sets identified by tag names.

Net::SFTP::Foreign::Constants provides values for all of the constants
listed in the SFTP protocol version 3 draft; the only thing to note is
that the constants are listed with the prefix C<SSH2_> instead of
C<SSH_>. So, for example, to import the constant for the file-open
command, you would write:

    use Net::SFTP::Foreign::Constants qw( SSH2_FXP_OPEN );

=head1 TAGS

As mentioned above, constants can either be imported individually
or in sets grouped by tag names. The tag names are:

=over 4

=item :fxp

Imports all of the C<SSH2_FXP_*> constants: these are the
constants used in the messaging protocol.

=item :flags

Imports all of the C<SSH2_FXF_*> constants: these are constants
used as flags sent to the server when opening files.

=item :att

Imports all of the C<SSH2_FILEXFER_ATTR_*> constants: these are
the constants used to construct the flag in the serialized
attributes. The flag describes what types of file attributes
are listed in the buffer.

=item :status

Imports all of the C<SSH2_FX_*> constants: these are constants
returned from a server C<SSH2_FXP_STATUS> message and indicate
the status of a particular operation.

=item :error

Imports all the C<SFTP_ERR_*> constants used to represent high level
errors: C<SFTP_ERR_LOCAL_ALREADY_EXISTS>,
C<SFTP_ERR_LOCAL_CHMOD_FAILED>, C<SFTP_ERR_LOCAL_OPEN_FAILED>,
C<SFTP_ERR_LOCAL_READ_ERROR>, C<SFTP_ERR_LOCAL_STAT_FAILED>,
C<SFTP_ERR_LOCAL_UTIME_FAILED>, C<SFTP_ERR_LOCAL_WRITE_FAILED>,
C<SFTP_ERR_REMOTE_BAD_PACKET_SEQUENCE>,
C<SFTP_ERR_REMOTE_BAD_PERMISSIONS>, C<SFTP_ERR_REMOTE_BAD_TIME>,
C<SFTP_ERR_REMOTE_BLOCK_TOO_SMALL>, C<SFTP_ERR_REMOTE_CLOSE_FAILED>,
C<SFTP_ERR_REMOTE_FSETSTAT_FAILED>, C<SFTP_ERR_REMOTE_FSTAT_FAILED>,
C<SFTP_ERR_REMOTE_LSTAT_FAILED>, C<SFTP_ERR_REMOTE_MKDIR_FAILED>,
C<SFTP_ERR_REMOTE_OPENDIR_FAILED>, C<SFTP_ERR_REMOTE_OPEN_FAILED>,
C<SFTP_ERR_REMOTE_READDIR_FAILED>, C<SFTP_ERR_REMOTE_READ_FAILED>,
C<SFTP_ERR_REMOTE_REALPATH_FAILED>, C<SFTP_ERR_REMOTE_REMOVE_FAILED>,
C<SFTP_ERR_REMOTE_RENAME_FAILED>, C<SFTP_ERR_REMOTE_RMDIR_FAILED>,
C<SFTP_ERR_REMOTE_READLINK_FAILED>, C<SFTP_ERR_REMOTE_SYMLINK_FAILED>,
C<SFTP_ERR_REMOTE_SETSTAT_FAILED>, C<SFTP_ERR_REMOTE_STAT_FAILED>,
C<SFTP_ERR_REMOTE_WRITE_FAILED> and
C<SFTP_ERR_REMOTE_HARDLINK_FAILED>.

Note: these constants are not defined on the SFTP draft.

=item :ext

Import all the C<SSH2_FXE_*> constants: there are the constants
defined for usage with SFTP extensions.

Currently, these are supported: C<SSH2_FXE_STATVFS_ST_RDONLY>,
C<SSH_FXE_STATVFS_ST_NOSUID>.

=back

There is one constant that does not fit into any of the
tag sets: C<SSH2_FILEXFER_VERSION>, which holds the value
of the SFTP protocol implemented by L<Net::SFTP::Foreign>.

=head1 AUTHOR & COPYRIGHTS

Please see the L<Net::SFTP::Foreign> manpage for author, copyright,
and license information.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Helpers.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Helpers;

our $VERSION = '1.68_04';

use strict;
use warnings;
use Carp qw(croak carp);

our @CARP_NOT = qw(Net::SFTP::Foreign);

use Scalar::Util qw(tainted);

require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw( _sort_entries
		  _gen_wanted
		  _ensure_list
                  _catch_tainted_args
                  _debug
                  _gen_converter
		  _hexdump
		  $debug
                );
our @EXPORT_OK = qw( _is_lnk
                     _is_dir
                     _is_reg
                     _do_nothing
		     _glob_to_regex
                     _file_part
                     _tcroak );

our $debug;

BEGIN {
    eval "use Time::HiRes 'time'"
	if ($debug and $debug & 256)
}

sub _debug {
    local $\;
    my $caller = '';
    if ( $debug & 8192) {
	$caller = (caller 1)[3];
	$caller =~ s/[\w:]*:://;
	$caller .= ': ';
    }
    if ($debug & 256) {
	my $ts = sprintf("%010.5f", time);
        print STDERR "#$$ $ts $caller", @_,"\n"
    }
    else {
        print STDERR "# $caller", @_,"\n"
    }
}

sub _hexdump {
    no warnings qw(uninitialized);
    my $data = shift;
    while ($data =~ /(.{1,32})/smg) {
        my $line=$1;
        my @c= (( map { sprintf "%02x",$_ } unpack('C*', $line)),
                (("  ") x 32))[0..31];
        $line=~s/(.)/ my $c=$1; unpack("c",$c)>=32 ? $c : '.' /egms;
	local $\;
        print STDERR join(" ", @c, '|', $line), "\n";
    }
}

sub _do_nothing {}

{
    my $has_sk;
    sub _has_sk {
	unless (defined $has_sk) {
            local $@;
            local $SIG{__DIE__};
	    eval { require Sort::Key };
	    $has_sk = ($@ eq '');
	}
	return $has_sk;
    }
}

sub _sort_entries {
    my $e = shift;
    if (_has_sk) {
	&Sort::Key::keysort_inplace(sub { $_->{filename} }, $e);
    }
    else {
	@$e = sort { $a->{filename} cmp $b->{filename} } @$e;
    }
}

sub _gen_wanted {
    my ($ow, $onw) = my ($w, $nw) = @_;
    if (ref $w eq 'Regexp') {
	$w = sub { $_[1]->{filename} =~ $ow }
    }

    if (ref $nw eq 'Regexp') {
	$nw = sub { $_[1]->{filename} !~ $onw }
    }
    elsif (defined $nw) {
	$nw = sub { !&$onw };
    }

    if (defined $w and defined $nw) {
	return sub { &$nw and &$w }
    }

    return $w || $nw;
}

sub _ensure_list {
    my $l = shift;
    return () unless defined $l;
    local $@;
    local $SIG{__DIE__};
    local $SIG{__WARN__};
    no warnings;
    (eval { @$l; 1 } ? @$l : $l);
}

sub _glob_to_regex {
    my ($glob, $strict_leading_dot, $ignore_case) = @_;

    my ($regex, $in_curlies, $escaping);
    my $wildcards = 0;

    my $first_byte = 1;
    while ($glob =~ /\G(.)/g) {
	my $char = $1;
	# print "char: $char\n";
	if ($char eq '\\') {
	    $escaping = 1;
	}
	else {
	    if ($first_byte) {
		if ($strict_leading_dot) {
		    $regex .= '(?=[^\.])' unless $char eq '.';
		}
		$first_byte = 0;
	    }
	    if ($char eq '/') {
		$first_byte = 1;
	    }
	    if ($escaping) {
		$regex .= quotemeta $char;
	    }
	    else {
                $wildcards++;
		if ($char eq '*') {
		    $regex .= ".*";
		}
		elsif ($char eq '?') {
		    $regex .= '.'
		}
		elsif ($char eq '{') {
		    $regex .= '(?:(?:';
		    ++$in_curlies;
		}
		elsif ($char eq '}') {
		    $regex .= "))";
		    --$in_curlies;
		    $in_curlies < 0
			and croak "invalid glob pattern";
		}
		elsif ($char eq ',' && $in_curlies) {
		    $regex .= ")|(?:";
		}
		elsif ($char eq '[') {
		    if ($glob =~ /\G((?:\\.|[^\]])+)\]/g) {
			$regex .= "[$1]"
		    }
		    else {
			croak "invalid glob pattern";
		    }
		}
		else {
                    $wildcards--;
		    $regex .= quotemeta $char;
		}
	    }

	    $escaping = 0;
	}
    }

    croak "invalid glob pattern" if $in_curlies;

    my $re = $ignore_case ? qr/^$regex$/i : qr/^$regex$/;
    wantarray ? ($re, ($wildcards > 0 ? 1 : undef)) : $re
}

sub _tcroak {
    if (${^TAINT} > 0) {
	push @_, " while running with -T switch";
        goto &croak;
    }
    if (${^TAINT} < 0) {
	push @_, " while running with -t switch";
        goto &carp;
    }
}

sub _catch_tainted_args {
    my $i;
    for (@_) {
        next unless $i++;
        if (tainted($_)) {
            my (undef, undef, undef, $subn) = caller 1;
            my $msg = ( $subn =~ /::([a-z]\w*)$/
                        ? "Insecure argument '$_' on '$1' method call"
                        : "Insecure argument '$_' on method call" );
            _tcroak($msg);
        }
        elsif (ref($_)) {
            for (grep tainted($_),
		 do { local ($@, $SIG{__DIE__}); eval { values %$_ }}) {
		my (undef, undef, undef, $subn) = caller 1;
		my $msg = ( $subn =~ /::([a-z]\w*)$/
			    ? "Insecure argument on '$1' method call"
			    : "Insecure argument on method call" );
		_tcroak($msg);
            }
        }
    }
}

sub _gen_dos2unix {
    my $unix2dos = shift;
    my $name = ($unix2dos ? 'unix2dos' : 'dos2unix');
    my $previous;
    my $done;
    sub {
        $done and die "Internal error: bad calling sequence for $name transformation";
        my $adjustment = 0;
        for (@_) {
            if ($debug and $debug & 128) {
                _debug ("before $name: previous: $previous, data follows...");
                _hexdump($_);
            }
            if (length) {
                if ($previous) {
                    $adjustment++;
                    $_ = "\x0d$_";
                }
                $adjustment -= $previous = s/\x0d\z//s;
                if ($unix2dos) {
                    $adjustment += s/(?<!\x0d)\x0a/\x0d\x0a/gs;
                }
                else {
                    $adjustment -= s/\x0d\x0a/\x0a/gs;
                }
            }
            elsif ($previous) {
                $previous = 0;
                $done = 1;
                $adjustment++;
                $_ = "\x0d";
            }
            if ($debug and $debug & 128) {
                _debug ("after $name: previous: $previous, adjustment: $adjustment, data follows...");
                _hexdump($_);
            }
            return $adjustment;
        }
    }
}

sub _gen_converter {
    my $conversion = shift;

    return undef unless defined $conversion;

    if (ref $conversion) {
        if (ref $conversion eq 'CODE') {
            return sub {
                my $before = length $_[0];
                $conversion->($_[0]);
                length($_[0]) - $before;
            }
        }
        else {
            croak "unsupported conversion argument"
        }
    }
    elsif ($conversion eq 'dos2unix') {
        return _gen_dos2unix(0);
    }
    elsif ($conversion eq 'unix2dos') {
        return _gen_dos2unix(1);
    }
    else {
        croak "unknown conversion '$conversion'";
    }
}

sub _is_lnk { (0120000 & shift) == 0120000 }
sub _is_dir { (0040000 & shift) == 0040000 }
sub _is_reg { (0100000 & shift) == 0100000 }

sub _file_part {
    my $path = shift;
    $path =~ m{([^/]*)$} or croak "unable to get file part from path '$path'";
    $1;
}

1;

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Local.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Local;

our $VERSION = '1.57';

use strict;
use warnings;
use Carp;
use File::Spec;

use Net::SFTP::Foreign::Attributes;
use Net::SFTP::Foreign::Constants qw(:error);
use Net::SFTP::Foreign::Helpers qw(_sort_entries _gen_wanted _do_nothing);
require Net::SFTP::Foreign::Common;
our @ISA = qw(Net::SFTP::Foreign::Common);

sub new {
    my $class = shift;
    my $self = { status => 0,
		 error => 0 };
    bless $self, $class;
}

sub realpath {
    $! = 0;
    File::Spec->rel2abs($_[1])
}

sub stat {
    $! = 0;
    my $a = Net::SFTP::Foreign::Attributes->new_from_stat(CORE::stat($_[1]));
    unless ($a) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_STAT_FAILED, "Couldn't stat local file '$_[1]'", $!);
    }
    $a
}

sub lstat {
    $! = 0;
    my $a = Net::SFTP::Foreign::Attributes->new_from_stat(CORE::lstat($_[1]));
    unless ($a) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_STAT_FAILED, "Couldn't stat local file '$_[1]'", $!);
    }
    $a
}

sub readlink {
    $! = 0;
    my $target = readlink $_[1];
    unless (defined $target) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_READLINK_FAILED, "Couldn't read link '$_[1]'", $!);
    }
    $target
}

sub join {
    shift;
    my $path = File::Spec->join(@_);
    $path = File::Spec->canonpath($path);
    # print 'lfs->join("'.join('", "', @_)."\") => $path\n";
    $path
}

sub ls {
    my ($self, $dir, %opts) = @_;

    my $ordered = delete $opts{ordered};
    my $follow_links = delete $opts{follow_links};
    my $atomic_readdir = delete $opts{atomic_readdir};

    my $wanted = delete $opts{_wanted} ||
	_gen_wanted(delete $opts{wanted},
		    delete $opts{no_wanted});

    %opts and croak "invalid option(s) '".CORE::join("', '", keys %opts)."'";

    $! = 0;

    opendir(my $ldh, $dir)
	or return undef;

    my @dir;
    while (defined(my $part = readdir $ldh)) {
	my $fn = File::Spec->join($dir, $part);
	my $a = $self->lstat($fn);
	if ($a and $follow_links and S_ISLNK($a->perm)) {
	    if (my $fa = $self->stat($fn)) {
		$a = $fa;
	    }
	    else {
		$! = 0;
	    }
	}
	my $entry = { filename => $part,
		      a => $a };
	if ($atomic_readdir or !$wanted or $wanted->($self, $entry)) {
	    push @dir, $entry;
	}
    }

    if ($atomic_readdir and $wanted) {
	@dir = grep { $wanted->($self, $_) } @dir;
    }

    _sort_entries(\@dir) if $ordered;

    return \@dir;
}

1;

__END__

=head1 NAME

Net::SFTP::Foreign::Local - access local fs with Net::SFTP::Foreign API.

=head1 SYNOPSIS

    my $localfs = Net::SFTP::Foreign::Local->new;
    my @find = $localfs->find('.', no_wanted => qr/(?:\/|^).svn/);

=head1 DESCRIPTION

This module is a partial implementation of the L<Net::SFTP::Foreign>
interface for the local filesystem.

The methods currently implemented are: C<stat>, C<lstat>, C<ls> and
C<find>.

=head1 COPYRIGHT

Copyright (c) 2006 Salvador FandiE<ntilde>o.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut

SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign/Backend";
    open(FILE, ">$dir/Net/SFTP/Foreign/Backend/Unix.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Backend::Unix;

our $VERSION = '1.68_08';

use strict;
use warnings;

use Carp;
our @CARP_NOT = qw(Net::SFTP::Foreign);

use Fcntl qw(O_NONBLOCK F_SETFL F_GETFL);
use POSIX ();
use Net::SFTP::Foreign::Helpers qw(_tcroak _ensure_list _debug _hexdump $debug);
use Net::SFTP::Foreign::Constants qw(SSH2_FX_BAD_MESSAGE
				     SFTP_ERR_REMOTE_BAD_MESSAGE);

sub _new { shift }

sub _defaults {
   ( default_queue_size => 32 )
}

sub _init_transport_streams {
    my (undef, $sftp) = @_;
    for my $dir (qw(ssh_in ssh_out)) {
	binmode $sftp->{$dir};
	my $flags = fcntl($sftp->{$dir}, F_GETFL, 0);
	fcntl($sftp->{$dir}, F_SETFL, $flags | O_NONBLOCK);
    }
}

sub _open_dev_null {
    my $sftp = shift;
    my $dev_null;
    unless (open $dev_null, '>', "/dev/null") {
	$sftp->_conn_failed("Unable to redirect stderr to /dev/null");
	return;
    }
    $dev_null
}

sub _fileno_dup_over {
    my ($good_fn, $fh) = @_;
    if (defined $fh) {
        my @keep_open;
        my $fn = fileno $fh;
        for (1..5) {
            $fn >= $good_fn and return $fn;
            $fn = POSIX::dup($fn);
            push @keep_open, $fn;
        }
        POSIX::_exit(255);
    }
    undef;
}

sub _open4 {
    my $backend = shift;
    my $sftp = shift;
    my ($dad_in, $dad_out, $child_in, $child_out);
    unless (pipe ($dad_in, $child_out) and
            pipe ($child_in, $dad_out)) {
        $sftp->_conn_failed("Unable to created pipes: $!");
        return;
    }
    my $pid = fork;
    unless ($pid) {
        unless (defined $pid) {
            $sftp->_conn_failed("Unable to fork new process: $!");
            return;
        }
        close ($dad_in);
        close ($dad_out);

        shift; shift;
        my $child_err = shift;
        my $pty = shift;

        $pty->make_slave_controlling_terminal if defined $pty;

        my $child_err_fno = eval { no warnings; fileno($child_err  ? $child_err : *STDERR) };
        my $child_err_safe; # passed handler may be tied, so we
                            # duplicate it in order to get a plain OS
                            # handler.
        if (defined $child_err_fno and $child_err_fno >= 0) {
            open $child_err_safe, ">&=$child_err_fno" or POSIX::_exit(1);
        }
        else {
            open $child_err_safe, ">/dev/null" or POSIX::_exit(1);
        }

        my $child_in_fno       = _fileno_dup_over(0 => $child_in      );
        my $child_out_fno      = _fileno_dup_over(1 => $child_out     );
        my $child_err_safe_fno = _fileno_dup_over(2 => $child_err_safe);

        unless (($child_in_fno       == 0 or POSIX::dup2($child_in_fno,       0)) and
                ($child_out_fno      == 1 or POSIX::dup2($child_out_fno,      1)) and
                ($child_err_safe_fno == 2 or POSIX::dup2($child_err_safe_fno, 2))) {
            POSIX::_exit(1);
        }
        do { exec @_ };
        POSIX::_exit(1);
    }
    close $child_in;
    close $child_out;

    $_[0] = $dad_in;
    $_[1] = $dad_out;
    $pid;
}

sub _init_transport {
    my ($backend, $sftp, $opts) = @_;

    my $transport = delete $opts->{transport};

    if (defined $transport) {
	if (ref $transport eq 'ARRAY') {
            @{$sftp}{qw(ssh_in ssh_out pid)} = @$transport;
        }
        else {
            $sftp->{ssh_in} = $sftp->{ssh_out} = $transport;
            $sftp->{_ssh_out_is_not_dupped} = 1;
        }
    }
    else {
        my $pass = delete $opts->{passphrase};
	my $pass_is_passphrase;
        if (defined $pass) {
            $pass_is_passphrase = 1;
        }
        else {
            $pass = delete $opts->{password};
	    defined $pass and $sftp->{_password_authentication} = 1;
        }

        my $expect_log_user = delete $opts->{expect_log_user} || 0;
	my $stderr_discard = delete $opts->{stderr_discard};
	my $stderr_fh = ($stderr_discard ? undef : delete $opts->{stderr_fh});
        my $open2_cmd = delete $opts->{open2_cmd};
        my $ssh_cmd_interface = delete $opts->{ssh_cmd_interface};

	my @open2_cmd;
        if (defined $open2_cmd) {
            @open2_cmd = _ensure_list($open2_cmd);
        }
        else {
            my $host = delete $opts->{host};
            defined $host or croak "sftp target host not defined";

            my $key_path = delete $opts->{key_path};

            my $ssh_cmd = delete $opts->{ssh_cmd};
            $ssh_cmd = 'ssh' unless defined $ssh_cmd;
            @open2_cmd = _ensure_list $ssh_cmd;

            unless (defined $ssh_cmd_interface) {
                $ssh_cmd_interface = ( "@open2_cmd" =~ /\bplink\b/i ? 'plink'  :
                                       "@open2_cmd" =~ /\bsshg3\b/i ? 'tectia' :
                                                                      'ssh'    );
            }

            my $port = delete $opts->{port};
            my $user = delete $opts->{user};
	    my $ssh1 = delete $opts->{ssh1};

            my $more = delete $opts->{more};
            defined $more and !ref($more) and $more =~ /^-\w\s+\S/ and
                warnings::warnif("Net::SFTP::Foreign", "'more' argument looks like it should be split first");
            my @more = _ensure_list $more;

            my @preferred_authentications;
            if (defined $key_path) {
                push @preferred_authentications, 'publickey' if defined $key_path;
                push @open2_cmd, -i => $key_path;
            }

            if ($ssh_cmd_interface eq 'plink') {
                push @open2_cmd, -P => $port if defined $port;
                if (defined $pass and !$pass_is_passphrase) {
                    warnings::warnif("Net::SFTP::Foreign", "using insecure password authentication with plink");
                    push @open2_cmd, -pw => $pass;
                    undef $pass;
                }

            }
            elsif ($ssh_cmd_interface eq 'ssh') {
                push @open2_cmd, -p => $port if defined $port;
		if (defined $pass and !$pass_is_passphrase) {
		    push @open2_cmd, -o => 'NumberOfPasswordPrompts=1';
                    push @preferred_authentications, ('keyboard-interactive', 'password');
		}
                if (@preferred_authentications
                    and not grep { $more[$_] eq '-o' and
                                       $more[$_ + 1] =~ /^PreferredAuthentications\W/ } 0..$#more-1) {
                    push @open2_cmd, -o => 'PreferredAuthentications=' . join(',', @preferred_authentications);
                }
            }
            elsif ($ssh_cmd_interface eq 'tectia') {
            }
            else {
                die "Unsupported ssh_cmd_interface '$ssh_cmd_interface'";
            }

            push @open2_cmd, -l => $user if defined $user;
            push @open2_cmd, @more;
            push @open2_cmd, $host;
	    push @open2_cmd, ($ssh1 ? "/usr/lib/sftp-server" : -s => 'sftp');
        }

        my $redirect_stderr_to_tty = ( defined $pass and
                                       ( delete $opts->{redirect_stderr_to_tty} or $ssh_cmd_interface eq 'tectia' ) );

        $redirect_stderr_to_tty and ($stderr_discard or $stderr_fh)
            and croak "stderr_discard or stderr_fh can not be used together with password/passphrase "
                          . "authentication when Tectia client is used";

	$debug and $debug & 1 and _debug "ssh cmd: @open2_cmd\n";

	%$opts and return; # Net::SFTP::Foreign will find the
                           # unhandled options and croak

	if (${^TAINT} and Scalar::Util::tainted($ENV{PATH})) {
            _tcroak('Insecure $ENV{PATH}')
        }

	if ($stderr_discard) {
	    $stderr_fh = $backend->_open_dev_null($sftp) or return;
	}

        if (defined $pass) {

            # user has requested to use a password or a passphrase for
            # authentication we use Expect to handle that

            eval { require IO::Pty };
            $@ and croak "password authentication is not available, IO::Pty and Expect are not installed";
            eval { require Expect };
            $@ and croak "password authentication is not available, Expect is not installed";

            local ($ENV{SSH_ASKPASS}, $ENV{SSH_AUTH_SOCK}) if $pass_is_passphrase;

            my $name = $pass_is_passphrase ? 'Passphrase' : 'Password';
            my $eto = $sftp->{_timeout} ? $sftp->{_timeout} * 4 : 120;

	    my $child;
	    my $expect;
            my $pty = IO::Pty->new;
            $expect = Expect->init($pty);
            $expect->raw_pty(1);
            $expect->log_user($expect_log_user);

            $redirect_stderr_to_tty and $stderr_fh = $pty->slave;

            $child = $backend->_open4($sftp, $sftp->{ssh_in}, $sftp->{ssh_out}, $stderr_fh, $pty, @open2_cmd);
            unless (defined $child) {
                $sftp->_conn_failed("Bad ssh command", $!);
                return;
            }
            $sftp->{pid} = $child;
            $sftp->{_expect} = $expect;

            unless($expect->expect($eto, ':', '?')) {
                $sftp->_conn_failed("$name not requested as expected", $expect->error);
                return;
            }
	    my $before = $expect->before;
	    if ($before =~ /^The authenticity of host /i or
		$before =~ /^Warning: the \w+ host key for /i) {
		$sftp->_conn_failed("the authenticity of the target host can not be established, connect from the command line first");
		return;
	    }
            $expect->send("$pass\n");
	    $sftp->{_password_sent} = 1;

            unless ($expect->expect($eto, "\n")) {
                $sftp->_conn_failed("$name interchange did not complete", $expect->error);
                return;
            }
	    $expect->close_slave();
        }
        else {
	    $sftp->{pid} = $backend->_open4($sftp, $sftp->{ssh_in}, $sftp->{ssh_out}, $stderr_fh, undef, @open2_cmd);
            unless (defined $sftp->{pid}) {
                $sftp->_conn_failed("Bad ssh command", $!);
                return;
            }
        }
    }
    $backend->_init_transport_streams($sftp);
}

sub _after_init {
    my ($backend, $sftp) = @_;
    unless ($sftp->error) {
        # do not propagate signals sent from the terminal to the
        # slave SSH:
        local ($@, $!);
        eval { setpgrp($sftp->{pid}, 0) };
    }
}

sub _do_io {
    my (undef, $sftp, $timeout) = @_;

    $debug and $debug & 32 and _debug(sprintf "_do_io connected: %s", $sftp->{_connected} || 0);

    return undef unless $sftp->{_connected};

    my $fnoout = fileno $sftp->{ssh_out};
    my $fnoin = fileno $sftp->{ssh_in};
    my ($rv, $wv) = ('', '');
    vec($rv, $fnoin, 1) = 1;
    vec($wv, $fnoout, 1) = 1;

    my $bin = \$sftp->{_bin};
    my $bout = \$sftp->{_bout};

    local $SIG{PIPE} = 'IGNORE';

    my $len;
    while (1) {
        my $lbin = length $$bin;
	if (defined $len) {
            return 1 if $lbin >= $len;
	}
	elsif ($lbin >= 4) {
            $len = 4 + unpack N => $$bin;
            if ($len > 256 * 1024) {
                $sftp->_set_status(SSH2_FX_BAD_MESSAGE);
                $sftp->_set_error(SFTP_ERR_REMOTE_BAD_MESSAGE,
                                  "bad remote message received");
                return undef;
            }
            return 1 if $lbin >= $len;
        }

        my $rv1 = $rv;
        my $wv1 = length($$bout) ? $wv : '';

        $debug and $debug & 32 and _debug("_do_io select(-,-,-, ". (defined $timeout ? $timeout : 'undef') .")");

        my $n = select($rv1, $wv1, undef, $timeout);
        if ($n > 0) {
            if (vec($wv1, $fnoout, 1)) {
                my $written = syswrite($sftp->{ssh_out}, $$bout, 64 * 1024);
                if ($debug and $debug & 32) {
		    _debug (sprintf "_do_io write queue: %d, syswrite: %s, max: %d, \$!: %s",
			    length $$bout,
			    (defined $written ? $written : 'undef'),
			    64 * 1024, $!);
		    $debug & 2048 and $written and _hexdump(substr($$bout, 0, $written));
		}
                if ($written) {
                    substr($$bout, 0, $written, '');
                }
                elsif ($! != Errno::EAGAIN() and $! != Errno::EINTR()) {
                    $sftp->_conn_lost;
                    return undef;
                }
            }
            if (vec($rv1, $fnoin, 1)) {
                my $read = sysread($sftp->{ssh_in}, $$bin, 64 * 1024, length($$bin));
                if ($debug and $debug & 32) {
		    _debug (sprintf "_do_io read sysread: %s, total read: %d, \$!: %s",
			    (defined $read ? $read : 'undef'),
			    length $$bin,
			    $!);
		    $debug & 1024 and $read and _hexdump(substr($$bin, -$read));
		}
                if (!$read and $! != Errno::EAGAIN() and $! != Errno::EINTR()) {
                    $sftp->_conn_lost;
                    return undef;
                }
            }
        }
        else {
            $debug and $debug & 32 and _debug "_do_io select failed: $!";
            next if ($n < 0 and ($! == Errno::EINTR() or $! == Errno::EAGAIN()));
            return undef;
        }
    }
}

1;
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Backend/Windows.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Backend::Windows;

our $VERSION = '1.68_07';

use strict;
use warnings;

use Carp;
our @CARP_NOT = qw(Net::SFTP::Foreign);

use IPC::Open3;
use POSIX ();
use Net::SFTP::Foreign::Helpers;
use Net::SFTP::Foreign::Constants qw(SSH2_FX_BAD_MESSAGE
				     SFTP_ERR_REMOTE_BAD_MESSAGE);

require Net::SFTP::Foreign::Backend::Unix;
our @ISA = qw(Net::SFTP::Foreign::Backend::Unix);

sub _defaults {
    ( default_queue_size => 4 )
}

sub _init_transport_streams {
    my ($backend, $sftp) = @_;
    binmode $sftp->{ssh_in};
    binmode $sftp->{ssh_out};
}

sub _open_dev_null {
    my $sftp = shift;
    my $dev_null;
    unless (open $dev_null, '>', 'NUL:') {
	$sftp->_conn_failed("Unable to redirect stderr for slave SSH process to NUL: $!");
	return;
    }
    $dev_null
}

sub _open4 {
    my $backend = shift;
    my $sftp = shift;

    defined $_[3] and croak "setting child PTY is not supported on Windows";

    my $fno = eval { defined $_[2] ? fileno $_[2] : fileno *STDERR };
    unless (defined $fno and $fno >= 0) {
        $sftp->_conn_failed("STDERR or stderr_fh is not a real file handle: " . (length $@ ? $@ : $!));
        return;
    }

    local *SSHERR;
    unless (open(SSHERR, ">>&=", $fno)) {
        $sftp->_conn_failed("Unable to duplicate stderr redirection file handle: $!");
        return undef;
    }

    goto NOTIE unless tied *STDERR;
    local *STDERR;
    unless (open STDERR, ">&=2") {
        $sftp->_conn_failed("Unable to reattach STDERR to fd 2: $!");
        return;
    }
 NOTIE:
    local ($@, $SIG{__DIE__}, $SIG{__WARN__});

    my $ppid = $$;
    my $pid = eval { open3(@_[1,0], ">&SSHERR", @_[4..$#_]) };
    $ppid == $$ or POSIX::_exit(-1);
    $pid;
}

sub _after_init {}

sub _sysreadn {
    my ($sftp, $n) = @_;
    my $bin = \$sftp->{_bin};
    while (1) {
	my $len = length $$bin;
	return 1 if $len >= $n;
	my $read = sysread($sftp->{ssh_in}, $$bin, $n - $len, $len);
	unless ($read) {
	    $sftp->_conn_lost;
	    return undef;
	}
    }
    return $n;
}

sub _do_io {
    my ($backend, $sftp, $timeout) = @_;

    return undef unless $sftp->{_connected};

    my $bin = \$sftp->{_bin};
    my $bout = \$sftp->{_bout};

    while (length $$bout) {
	my $written = syswrite($sftp->{ssh_out}, $$bout, 20480);
	unless ($written) {
	    $sftp->_conn_lost;
	    return undef;
	}
	substr($$bout, 0, $written, "");
    }

    defined $timeout and $timeout <= 0 and return;

    _sysreadn($sftp, 4) or return undef;

    my $len = 4 + unpack N => $$bin;
    if ($len > 256 * 1024) {
        $sftp->_set_status(SSH2_FX_BAD_MESSAGE);
        $sftp->_set_error(SFTP_ERR_REMOTE_BAD_MESSAGE,
                          "bad remote message received");
        return undef;
    }
    _sysreadn($sftp, $len);
}

1;
SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign/Attributes";
    open(FILE, ">$dir/Net/SFTP/Foreign/Attributes/Compat.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Attributes::Compat;

our $VERSION = '0.01';

use strict;
use warnings;

use Net::SFTP::Foreign::Attributes;
our @ISA = qw(Net::SFTP::Foreign::Attributes);

my @fields = qw( flags size uid gid perm atime mtime );

for my $f (@fields) {
    no strict 'refs';
    *$f = sub { @_ > 1 ? $_[0]->{$f} = $_[1] : $_[0]->{$f} || 0 }
}

sub new {
    my ($class, %param) = @_;

    my $a = $class->SUPER::new();

    if (my $stat = $param{Stat}) {
	$a->set_size($stat->[7]);
	$a->set_ugid($stat->[4], $stat->[5]);
	$a->set_perm($stat->[2]);
	$a->set_amtime($stat->[8], $stat->[9]);
    }
    $a;
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Attributes::Compat - adaptor for Net::SFTP::Attributes compatibility

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Attributes::Compat;
    my $attrs = Net::SFTP::Foreign::Attributes->new(Stat => [ stat "foo" ]);
    my $size = $attrs->size;

=head1 DESCRIPTION

This module provides a wrapper for L<Net::SFTP::Foreign::Attributes>
exposing an API compatible to L<Net::SFTP::Attributes>.

=head1 AUTHOR & COPYRIGHTS

Please see the Net::SFTP::Foreign manpage for author, copyright, and
license information.

=cut
SFTPMODULE
;
    close FILE;
    push(@INC, $dir);
    require Net::SFTP::Foreign;
}
